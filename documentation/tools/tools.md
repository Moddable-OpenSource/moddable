# Tools

Copyright 2017 Moddable Tech, Inc.

Revised: October 6, 2017

**Warning**: These notes are preliminary. Omissions and errors are likely. If you encounter problems, please ask for assistance.


## Build

This document presents the tools provided by Moddable to build, debug and run JavaScript apps on micro-controllers or in the Moddable simulator, **Screen Test**.

The tools compile and link JavaScript modules, and prepare assets for specific platforms and specific screens. The only tools you will use directly are **mcconfig** and **xsbug**. The other tools are used indirectly, thru the make file generated by **mcconfig**, but are nevertheless presented here to help you understand what is happening under the hood.    

To build the tools themselves, and to build and run apps in the Moddable simulator, you will only need standard development tools. To build and run apps on micro-controllers, you will also need the micro-controllers toolchains to compile and link C code, and to transfer apps to flash storage. 

### macOS

Install **Xcode** and the **Xcode Command Line Tools**. 

Define and export the `MODDABLE` environment variable in your `.bashrc` file:
	
	MODDABLE=~/Projects/moddable
	export MODDABLE

Build the tools:

	cd $MODDABLE/build/makefiles/mac
	make
	
All the tools are built into the `$MODDABLE/build/bin/mac/debug` and `$MODDABLE/build/bin/mac/release` folders. To use the tools easily, add `$MODDABLE/build/bin/mac/release` to your `PATH` environment variable.

**Screen Test** and **xsbug** are standard macOS applications. It is practical to keep **xsbug** in dock for instance.

### Linux

The **GCC** development tools are usually ready. You may need to install the development version of **GTK+ 3**. For instance:

	sudo apt-get install libgtk-3-dev

Define and export the `MODDABLE` environment variable in your `.bashrc` file:
	
	MODDABLE=~/Projects/moddable
	export MODDABLE

Build the tools:

	cd $MODDABLE/build/makefiles/lin
	make
	
All the tools are built into the `$MODDABLE/build/bin/lin/debug` and `$MODDABLE/build/bin/lin/release` folders. To use the tools easily, add `$MODDABLE/build/bin/lin/release` to your `PATH` environment variable.

To install the **Screen Test** and **xsbug** applications:

	cd $MODDABLE/build/makefiles/lin
	make install
	
Enter your `sudo` password to copy their desktop, executable and icon files into the standard `/usr/share/applications`, `/usr/bin` and `/usr/share/icons/hicolor` directories.

### Windows

Install **Microsoft Visual Studio Community 2017**. Select the *Desktop development with C++* option.

Use the *Control Panel* > *System and Security* > *System* > *Advanced system settings* > *Environment Variables* > *System Variables* > *New...* to define the `MODDABLE` environment variable.

Use the **x86 Native Tools Command Prompt for VS 2017** as your terminal.

	cd %MODDABLE%\build\makefiles\win
	build	

All the tools are built into the `$MODDABLE/build/bin/win/debug` and `$MODDABLE/build/bin/win/release` folders. To use the tools easily, add `$MODDABLE/build/bin/win/release` to your `PATH` environment variable.

The **Screen Test** and **xsbug** applications are standard Windows applications. It is practical to keep **xsbug** in the start menu for instance.


## mcconfig

**mcconfig** is a command line tool that generates a make file based on a manifest, then runs **make** to build and launch Moddable apps on micro-controllers or in the simulator. 

For instance:

	cd $MODDABLE/piu/examples/balls
	mcconfig -d -m

will build and launch "balls" in **Screen Test**, and:

	cd $MODDABLE/examples/piu/balls
	mcconfig -d -m -p esp
	
will build and launch "balls" on the ESP micro-controller.

The first app will take some time to build since all the ESP and XS libraries need to be compiled too. Such libraries are shared, so subsequent apps will build faster.

Of course the ESP needs to be connected to your Mac and **xsbug** needs to run on your Mac for the launch to be successful.

See the [Manifest](./Manifest.md) document for explanations about manifests.

### Arguments

	mcconfig [manifest] [-d] [f format] [-i] [-m] [-o directory] [p platform] [-r rotation] [-v]

- `manifest`: the manifest file. Defaults to the `manifest.json` file in the current directory or in the parent directory of the current directory.
- `-d`: to build a debug instrumented version.
- `-f format`: to select the screen pixel format: `gray16`, `gray256`, `rgb332`, `rgb565be` or `rgb565le`. Defaults to `rgb565le`. See **png2bmp** here under.
- `-i`: to build a release instrumented version.
- `-m`: to run make automatically, otherwise **mcconfig** just generates the make file.
- `-o directory`: the output directory. Defaults to the `$MODDABLE/build` directory.
- `-p platform`: to select the platform: `esp`, `esp32`, `win`, `lin` or `mac`. Defaults to `mac`
- `-r rotation`: to select the screen rotation: `0`, `90`, `180` or `270`. Defaults to `0`. See **png2bmp** here under.
- `-v`: to trace all commands executed by make

## mcrez

**mcrez** is a command line tool that includes assets into a resources map. **mcrez** generates C code that contains the assets themselves and a way to access them.

Moddable apps do not require a file system. Assets are accessed as resources, thanks to the `Resource` module.

	import Resource from "Resource";
	import parseBMP from "commodetto/ParseBMP";
	let bitmap = parseBMP(new Resource("balls-color.bmp"));

Notice that most assets are used directly from flash storage.

### Arguments

	mcrez files... [-o output] [-r name] [-p platform]

- `files`: the paths of the assets to include.
- `-o output`: the path of the output directory. Defaults to the current directory.
- `-r name`: the name of the generated C file. Defaults to `mc.resources.c`.
- `-p platform`: to select the platform: `esp`, `esp32`, `win`, `lin` or `mac`. Defaults to `mac`

## png2bmp

**png2bmp** is a command line tool that converts a PNG file into BMP files that Moddable apps can use directly from flash storage.

For instance:

	cd $MODDABLE/piu/examples/balls
	png2bmp balls.png -o ~/Desktop

will create two files on your dektop:

- `balls-alpha.bmp`: a 8-bit gray bitmap that defines the alpha channel.
- `balls-color.bmp`: a 16-bit color bitmap that defines the red, green and blue channels.

To be able to use bitmaps directly from flash storage, the bitmaps need to conform to the screen pixel format and rotation. Use the `-f` option to select the screen pixel format and the `-r` option to select the screen rotation. **png2bmp** also takes care of the row bytes constraint related to the screen pixel format. For instance:

	cd $MODDABLE/piu/examples/balls
	png2bmp balls.png -o ~/Desktop -f gray256 -r 90

![](./../assets/tools/png2bmp.png)

### Arguments
	
	png2bmp file.png [-a] [-c] [f format] [-o directory] [-r rotation]

- `-a`: to create only the alpha bitmap.
- `-c`: to create only the color bitmap.
- `-f format`: to select the screen pixel format: `gray16`, `gray256`, `rgb332`, `rgb565be` or `rgb565le`. Defaults to `rgb565le`.
- `-o directory`: the output directory. Defaults to the current directory.
- `-r rotation`: to select the screen rotation: `0`, `90`, `180` or `270`. Defaults to `0`.

## xsc

**xsc** is the XS compiler, a command line tool that compiles JS files into XS binary files containing symbols and byte codes. 

By default **xsc** parses the JS file as an ECMAScript module. Optionally, for compatibility and conformance, **xsc** can parse the JS file as an ECMAScript program or a CommonJS module. Moddable apps only uses ECMAScript modules.

With the `-c` option, **xsc** accepts the `@` constructs that reference host functions and host objects. For instance:

	class Point @ "Point_destructor" {
		constructor(x, y) @ "Point_constructor"
		moveBy(x, y) @ "Point_moveBy"
		get x() @ "Point_get_x"
		get y() @ "Point_get_y"
	}

The `Point` class creates host objects. The `Point_destructor` C function will be called when the garbage collector destroys such host objects. The `Point_constructor ` C function will be called when `new Point(x, y)` constructs such host objects. The other C functions will be called when accessing properties and calling methods. See **XS in C** about the implementation of the C functions.

Without the `-e` option, **xsc** generates C code that declares XS symbols and the interface of the host functions. Such C code can then be compiled and linked with the implementation of the host functions to build a dynamic library.

With the  `-e` option, **xsc** embeds the references to host functions and host objects into the XS binary file. It is the linker, **xsl**, that will generate C code for all the modules. That is how Moddable apps work. 

### Arguments

	xsc file [-c] [-d] [-e] [-m] [-o directory] [-p] [-r name] [-t directory]

- `file`: the path of a JS file to compile.
- `-c`: to accept the `@` constructs that reference host functions and host objects. With the `-c` option and without the `-e` option, **xsc** generates C code that declares XS symbols, host functions and host objects.
- `-d`: to generate the file and line byte codes that allow to debug the JS file.
- `-e`: to embed references to host functions and host objects into the XS binary files instead of generating C code. This options is required to compile a JS file into an XS binary file that **xsl** can link into an XS archive file.
- `-m`: to parse the JS file as a CommonJS module.
- `-o directory`: the path of the output directory. Defaults to the current directory.
- `-p`: to parse the JS file as an ECMAScript program.
- `-r name`: the name of the output file. Defaults to the name of the input file. The output extension is always `.xsb`.
- `-t directory`: the path of the temporary directory. Defaults to the output directory. With the `-c` option and without the `-e` option, **xsc** generates C code in the temporary directory.

## xsl

**xsl** is the XS linker, a command line tool that links several XS binary files into one XS archive file, and generates C code that declares XS symbols and the interface of the host functions.

With the `-p` option, **xsl** can also preload modules and generate C code that defines a read-only XS virtual machine suitable to be cloned to run apps. That is how Moddable apps work. 

The C code can then be compiled and linked with the implementation of the host functions to build a dynamic library or an executable.

### Arguments

	xsl files... [-a name] [-b directory] [c creation] [-o directory] [-p modules]... [u url]

- `files`: the paths of the XS binary files to link.
- `-a name`: the name of the XS archive file. Defaults to `a`. 
- `-b directory`: the path of the base directory. Defaults to the output directory. The names of the modules in the archive are the paths of the XS binary files, relative to the base directory. It is an error to link XS binary files which are not directly or indirectly inside the base directory.
- `-c creation`: the parameters that will be used to create the cloned machines. 
- `-o directory`: the path of the output directory. Defaults to the current directory.
- `-p module`: the name of a module to preload. Use one `-p module` option by module to preload.
- `-u url`: the base URL of the modules in the archive. Defaults to `/`.

## Screen Test

**Screen Test** is the Moddable simulator, a macOS, Linux or Windows application that hosts an XS machine to run Moddable apps in a simulator screen.

![](./../assets/tools/screen-test.png)

For the Moddable simulator, Moddable apps are dynamic libraries (mc.so or mc.dll) built by mcconfig. **Screen Test** loads such dynamic libraries and executes their main module.

The `Open...` and `Close` items of the application menu allows to open and close a Moddable app. You can also drag and drop a Moddable app on the Screen Test icon or window.

Notice that the make file generated by **mcconfig** automatically launches Moddable apps in **Screen Test**.

The `Touch Mode` item of the application menu toggles the touch mode on and off. When the touch mode is on, your track pad is mapped to the simulator screen to test the multitouch features of your app.

The `Size` menu allows to change the simulator screen. The  Moddable app quits and relaunches when the simulator screen changes.

The `Format` menu allows to inspect the pixel format your app has been built for.
