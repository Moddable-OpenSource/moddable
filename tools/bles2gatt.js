/*
 * Copyright (c) 2016-2022 Moddable Tech, Inc.
 *
 *   This file is part of the Moddable SDK Tools.
 * 
 *   The Moddable SDK Tools is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 * 
 *   The Moddable SDK Tools is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 * 
 *   You should have received a copy of the GNU General Public License
 *   along with the Moddable SDK Tools.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

import { FILE, TOOL } from "tool";

class GATTFile {
	constructor(dictionary) {
		this.tool = dictionary.tool;
		this.client = dictionary.client;
		this.server = dictionary.server;
		this.nimble = dictionary.nimble;
		this.file = dictionary.file;
		this.services = dictionary.services;
	}
	generate() {}
};

class ESP32GATTFile extends GATTFile {
	constructor(dictionary) {
		super(dictionary);
		this.sdkconfig = dictionary.sdkconfig;
	}
};

class BluedroidGATTFile extends ESP32GATTFile {
	generate() {
		let tool = this.tool;
		let file = this.file;
		let services = this.services;
		file.line('/* WARNING: This file is automatically generated. Do not edit. */');
		file.line("");
		file.line("typedef struct {");
		file.line("\tuint8_t service_index;");
		file.line("\tuint8_t att_index;");
		file.line("\tconst char *name;");
		file.line("\tconst char *type;");
		file.line("} char_name_table;");
		file.line("");
		if (0 == services.length) {
			file.line("#define service_count 0");
			file.line("#define char_name_count 0");
			file.line("#define max_attribute_count 0");
			file.line("");
			file.line("static const uint8_t attribute_counts[0] = {};");
			file.line("static const esp_gatts_attr_db_t gatt_db[0][0] = {};");
			file.line("static const char_name_table char_names[0] = {};");
			return;
		}
		var attributeIndex = 0;
		var char_names = [];
		file.line("#define CHAR_DECLARATION_SIZE (sizeof(uint8_t))");
		file.line("");
		file.line("static const uint16_t primary_service_uuid = 0x2800;");
		file.line("static const uint16_t character_declaration_uuid = 0x2803;");
		file.line("static const uint16_t character_client_config_uuid = 0x2902;");
		file.line("");
		
		var maxAttributeCount = 0;
		var attributeCounts = new Array(services.length);
		var characteristicIndex = 0;
		var descriptorIndex = 0;
		services.forEach((service, index) => {
			let attributeCount = 1;
			let characteristics = service.characteristics;
			attributeCount += (Object.keys(characteristics).length * 2);
			for (let key in characteristics) {
				let characteristic = characteristics[key];
				if ((undefined === characteristic.permissions) && this.client)
					characteristic.permissions = "read";
				if ((undefined === characteristic.properties) && this.client)
					characteristic.properties = "read";
				let properties = characteristic.properties;
				if (properties.includes("notify") || properties.includes("indicate")) {
					++attributeCount;
					characteristic._notify = true;
				}
				if ("descriptors" in characteristic) {
					attributeCount += Object.keys(characteristic.descriptors).length;
					characteristic._descriptors = true;
				}
			}
			if (attributeCount > maxAttributeCount)
				maxAttributeCount = attributeCount;
			attributeCounts[index] = attributeCount;
			this.writeAttributeUUID(file, service, index, "service");
			for (let key in characteristics) {
				let characteristic = characteristics[key];
				this.writeAttributeUUID(file, characteristic, characteristicIndex, "char");
				if ("value" in characteristic) {
					this.writeAttributeValue(file, characteristic, characteristicIndex, "char");
				}
				if (characteristic._notify) {
					file.line(`static const uint8_t char_ccc${characteristicIndex}[2] = { 0x00, 0x00 };`);
				}
				let properties = this.parseProperties(characteristic.properties.split(","));
				file.line(`static const uint8_t char_properties${characteristicIndex} = ${toPaddedHex(properties)};`);
				if ("descriptors" in characteristic) {
					for (let key2 in characteristic.descriptors) {
						let descriptor = characteristic.descriptors[key2];
						this.writeAttributeUUID(file, descriptor, descriptorIndex, "desc");
						if ("value" in descriptor) {
							this.writeAttributeValue(file, descriptor, descriptorIndex, "desc");
						}
						++descriptorIndex;
					}
				}
				++characteristicIndex;
			}
			file.line("");
		});
		characteristicIndex = 0;
		descriptorIndex = 0;
		
		file.line(`#define service_count ${services.length}`);
		file.line(`#define max_attribute_count ${maxAttributeCount}`);
		file.write(`static const uint8_t attribute_counts[${services.length}] = { `);
		file.write(buffer2hexlist(attributeCounts));
		file.write(" };");
		file.line("");

		file.line(`static const esp_gatts_attr_db_t gatt_db[${services.length}][${maxAttributeCount}] = {`);
		services.forEach((service, index) => {
			attributeIndex = 0;
			file.line("\t{");
			
			// primary service attribute
			file.line(`\t\t// Service ${service.uuid}`);
			file.line("\t\t[", attributeIndex, "] = {");
			file.line("\t\t\t{ESP_GATT_AUTO_RSP},");
			file.line(`\t\t\t{ESP_UUID_LEN_16, (uint8_t*)&primary_service_uuid, ESP_GATT_PERM_READ, sizeof(uint16_t), sizeof(service_uuid${index}), (uint8_t*)&service_uuid${index}}`);
			file.line("\t\t},");
			++attributeIndex;
			
			let characteristics = service.characteristics;
			for (let key in characteristics) {
				let characteristic = characteristics[key];
				
				if ((undefined === characteristic.permissions) && this.client)
					characteristic.permissions = "read";
				if ((undefined === characteristic.properties) && this.client)
					characteristic.properties = "read";

				// characteristic declaration
				let permissions = this.parsePermissions(characteristic.permissions.split(","));
				file.line("\t\t[", attributeIndex, "] = {");
				file.line("\t\t\t{ESP_GATT_AUTO_RSP},");
				file.line(`\t\t\t{ESP_UUID_LEN_16, (uint8_t*)&character_declaration_uuid, ${permissions}, CHAR_DECLARATION_SIZE, CHAR_DECLARATION_SIZE, (uint8_t*)&char_properties${characteristicIndex}}`);
				file.line("\t\t},");
				++attributeIndex;

				// characteristic value
				let maxBytes;
				if (this.server && !this.client)
					maxBytes = characteristic.maxBytes;
				else
					maxBytes = ("maxBytes" in characteristic ? characteristic.maxBytes : 0);
				let esp_uuid_len = (4 == characteristic.uuid.length ? "ESP_UUID_LEN_16" : "ESP_UUID_LEN_128");
				file.line("\t\t[", attributeIndex, "] = {");
				if ("value" in characteristic)
					file.line("\t\t\t{ESP_GATT_AUTO_RSP},");
				else {
					file.line("\t\t\t{ESP_GATT_RSP_BY_APP},");
				}
				let char_name = { service_index:index, att_index:attributeIndex, name:key };
				char_name.type = characteristic.type ? characteristic.type: "";
				char_names.push(char_name);
				file.write(`\t\t\t{${esp_uuid_len}, (uint8_t*)&char_uuid${characteristicIndex}, ${permissions}, ${maxBytes}, `);
				if ("value" in characteristic)
					file.write(`${characteristic._length}, (uint8_t*)&char_value${characteristicIndex}}`);
				else
					file.write("0, NULL}");
				file.line("");
				file.line("\t\t},");
				++attributeIndex;
				
				// characteristic configuration descriptor
				if (characteristic._notify) {
					file.line("\t\t[", attributeIndex, "] = {");
					file.line("\t\t\t{ESP_GATT_AUTO_RSP},");
					file.line(`\t\t\t{ESP_UUID_LEN_16, (uint8_t*)&character_client_config_uuid, ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE, sizeof(uint16_t), sizeof(char_ccc${characteristicIndex}), (uint8_t*)char_ccc${characteristicIndex}}`);
					file.line("\t\t},");
					++attributeIndex;
				}
				
				// other characteristic descriptors
				if (characteristic._descriptors) {
					for (let key2 in characteristic.descriptors) {
						let descriptor = characteristic.descriptors[key2];
						if ((undefined === descriptor.permissions) && this.client)
							descriptor.permissions = "read";
						if ((undefined === descriptor.properties) && this.client)
							descriptor.properties = "read";
						if ((undefined === descriptor.maxBytes) && this.client)
							descriptor.maxBytes = 2;
						permissions = this.parsePermissions(descriptor.permissions.split(","));
						esp_uuid_len = (4 == descriptor.uuid.length ? "ESP_UUID_LEN_16" : "ESP_UUID_LEN_128");
						file.line("\t\t[", attributeIndex, "] = {");
						if ("value" in descriptor)
							file.line("\t\t\t{ESP_GATT_AUTO_RSP},");
						else {
							file.line("\t\t\t{ESP_GATT_RSP_BY_APP},");
						}
						let char_name = { service_index:index, att_index:attributeIndex, name:key2 };
						char_name.type = descriptor.type ? descriptor.type: "";
						char_names.push(char_name);
						file.write(`\t\t\t{${esp_uuid_len}, (uint8_t*)&desc_uuid${descriptorIndex}, ${permissions}, ${descriptor.maxBytes}, `);
						if ("value" in descriptor)
							file.write(`${descriptor._length}, (uint8_t*)&desc_value${descriptorIndex}}`);
						else
							file.write("0, NULL}");
						file.line("");
						file.line("\t\t},");
						++descriptorIndex;
						++attributeIndex;
					}
				}
				++characteristicIndex;
			}
			file.line("\t},");
		});
		file.line("};");
		file.line("");
		
		file.line(`#define char_name_count ${char_names.length}`);
		file.line(`static const char_name_table char_names[${char_names.length}] = {`);
		char_names.forEach(entry => {
			file.line(`\t{${entry.service_index}, ${entry.att_index}, "${entry.name}", "${entry.type}"},`);
		});
		file.line("};");
		file.line("");
	}
	parseProperties(properties) {
		const ESP_GATT_CHAR_PROP_BIT_READ = (1 << 1);
		const ESP_GATT_CHAR_PROP_BIT_WRITE_NR = (1 << 2);
		const ESP_GATT_CHAR_PROP_BIT_WRITE = (1 << 3);
		const ESP_GATT_CHAR_PROP_BIT_NOTIFY = (1 << 4);
		const ESP_GATT_CHAR_PROP_BIT_INDICATE = (1 << 5);
		const ESP_GATT_CHAR_PROP_BIT_AUTH = (1 << 6);
		const ESP_GATT_CHAR_PROP_BIT_EXT_PROP = (1 << 7);
		let props = 0;
		properties.forEach(p => {
			switch(p.trim()) {
				case "read":
					props |= ESP_GATT_CHAR_PROP_BIT_READ;
					break;
				case "write":
					props |= ESP_GATT_CHAR_PROP_BIT_WRITE;
					break;
				case "writeNoResponse":
					props |= ESP_GATT_CHAR_PROP_BIT_WRITE_NR;
					break;
				case "notify":
					props |= ESP_GATT_CHAR_PROP_BIT_NOTIFY;
					break;
				case "indicate":
					props |= ESP_GATT_CHAR_PROP_BIT_INDICATE;
					break;
				case "extended":
					props |= ESP_GATT_CHAR_PROP_BIT_EXT_PROP;
					break;
				default:
					throw new Error("unknown property");
			}
		});
		return props;
	}
	parsePermissions(permissions) {
		let perms = [];
		let readPerms = 0;
		let writePerms = 0;
		permissions.forEach(p => {
			switch(p.trim()) {
				case "read":
					++readPerms;
					perms.push("ESP_GATT_PERM_READ");
					break;
				case "readEncrypted":
					++readPerms;
					perms.push("ESP_GATT_PERM_READ_ENCRYPTED");
					break;
				case "write":
					++writePerms;
					perms.push("ESP_GATT_PERM_WRITE");
					break;
				case "writeEncrypted":
					++writePerms;
					perms.push("ESP_GATT_PERM_WRITE_ENCRYPTED");
					break;
				default:
					throw new Error("unsupported permission");
			}
		});
		if (readPerms > 1)
			throw new Error("only one of read/readEncrypted can be specified");
		if (writePerms > 1)
			throw new Error("only one of write/writeEncrypted can be specified");
			
		return perms.join("|");
	}
	writeAttributeValue(file, attribute, index, prefix) {
		let buffer = typedValueToBuffer(attribute.type, attribute.value);
		attribute._length = buffer.byteLength;
		file.write(`static const uint8_t ${prefix}_value${index}[${buffer.byteLength}] = { `);
		file.write(buffer2hexlist(buffer));
		file.write(" };");
		file.line("");
	}
	writeAttributeUUID(file, attribute, index, prefix) {
		let uuid = attribute.uuid;
		if (4 == uuid.length)
			file.line(`static const uint16_t ${prefix}_uuid${index} = 0x${uuid};`);
		else if (36 == uuid.length) {
			file.write(`static const uint8_t ${prefix}_uuid${index}[16] = { `);
			file.write(buffer2hexlist(uuid128toBuffer(uuid)));
			file.write(" };");
			file.line("");
		}
		else
			throw new Error("unsupported UUID length");
	}
};

class NimBLEGATTFile extends ESP32GATTFile {
	generate() {
		let tool = this.tool;
		let file = this.file;
		let services = this.services;
		file.line('/* WARNING: This file is automatically generated. Do not edit. */');
		file.line("");
		file.line("typedef struct {");
		file.line("\tuint8_t service_index;");
		file.line("\tuint8_t att_index;");
		file.line("\tconst char *name;");
		file.line("\tconst char *type;");
		file.line("} char_name_table;");
		file.line("");
		file.line("typedef struct {");
		file.line("\tconst uint8_t *value;");
		file.line("\tsize_t length;");
		file.line("} static_value;");
		file.line("");
		if (0 == services.length) {
			file.line("#define service_count 0");
			file.line("#define char_name_count 0");
			file.line("#define max_attribute_count 0");
			file.line("");
			file.line("static const uint8_t attribute_counts[0] = {};");
			file.line("static const struct ble_gatt_svc_def gatt_svr_svcs[] = {};");
			file.line("static const char_name_table char_names[0] = {};");
			return;
		}
		var attributeIndex = 0;
		var char_names = [];		
		var maxAttributeCount = 0;
		var attributeCounts = new Array(services.length);
		var characteristicIndex = 0;
		var descriptorIndex = 0;
		services.forEach((service, index) => {
			characteristicIndex = 0;
			attributeIndex = 0;
			let attributeCount = 0;
			let characteristics = service.characteristics;
			attributeCount += (Object.keys(characteristics).length);
			if (4 == service.uuid.length) {
				file.write(`static const ble_uuid16_t service${index}_uuid = BLE_UUID16_INIT(`);
				file.write(`0x${service.uuid}`);
				file.write(");");

			}
			else {
				file.write(`static const ble_uuid128_t service${index}_uuid = BLE_UUID128_INIT(`);
				file.write(buffer2hexlist(uuid128toBuffer(service.uuid)));
				file.write(");");
			}
			file.line("");
			for (let key in characteristics) {
				let characteristic = characteristics[key];
				if ((undefined === characteristic.permissions) && this.client)
					characteristic.permissions = "read";
				if ((undefined === characteristic.properties) && this.client)
					characteristic.properties = "read";
				if ("descriptors" in characteristic) {
					attributeCount += Object.keys(characteristic.descriptors).length;
					characteristic._descriptors = true;
				}
				if (4 == characteristic.uuid.length) {
					file.write(`static const ble_uuid16_t service${index}_chr${characteristicIndex}_uuid = BLE_UUID16_INIT(`);
					file.write(`0x${characteristic.uuid}`);
					file.write(");");

				}
				else {
					file.write(`static const ble_uuid128_t service${index}_chr${characteristicIndex}_uuid = BLE_UUID128_INIT(`);
					file.write(buffer2hexlist(uuid128toBuffer(characteristic.uuid)));
					file.write(");");
				}
				file.line("");
				if ("value" in characteristic) {
					let buffer = typedValueToBuffer(characteristic.type, characteristic.value);
					file.write(`static const uint8_t service${index}_chr${characteristicIndex}_value[${buffer.byteLength}] = { `);
					file.write(buffer2hexlist(buffer));
					file.write(" };");
					file.line("");
					file.line(`static static_value service${index}_chr${characteristicIndex}_value_struct = { .value = service${index}_chr${characteristicIndex}_value, .length = sizeof(service${index}_chr${characteristicIndex}_value)};`);
				}
				if (characteristic._descriptors) {
					descriptorIndex = 0;
					let descriptors = characteristic.descriptors;
					for (let key2 in descriptors) {
						let descriptor = descriptors[key2];
						if (4 == descriptor.uuid.length) {
							file.write(`static const ble_uuid16_t service${index}_chr${characteristicIndex}_dsc${descriptorIndex}_uuid = BLE_UUID16_INIT(`);
							file.write(`0x${descriptor.uuid}`);
							file.write(");");

						}
						else {
							file.write(`static const ble_uuid128_t service${index}_chr${characteristicIndex}_dsc${descriptorIndex}_uuid = BLE_UUID128_INIT(`);
							file.write(buffer2hexlist(uuid128toBuffer(descriptor.uuid)));
							file.write(");");
						}
						file.line("");
						if ("value" in descriptor) {
							let buffer = typedValueToBuffer(descriptor.type, descriptor.value);
							file.write(`static const uint8_t service${index}_chr${characteristicIndex}_dsc${descriptorIndex}_value[${buffer.byteLength}] = { `);
							file.write(buffer2hexlist(buffer));
							file.write(" };");
							file.line("");
							file.line(`static static_value service${index}_chr${characteristicIndex}_dsc${descriptorIndex}_value_struct = {.value = service${index}_chr${characteristicIndex}_dsc${descriptorIndex}_value, .length = sizeof(service${index}_chr${characteristicIndex}_dsc${descriptorIndex}_value)};`);
						}
						++descriptorIndex;
					}
				}
				if (this.server)
					file.line(`static uint16_t service${index}_chr${characteristicIndex}_handle;`);
					
				let char_name = { service_index:index, att_index:attributeIndex, name:key };
				char_name.type = characteristic.type ? characteristic.type: "";
				char_names.push(char_name);
				
				++characteristicIndex;
				++attributeIndex;

				if (characteristic._descriptors) {
					let descriptors = characteristic.descriptors;
					for (let key2 in descriptors) {						
						let descriptor = descriptors[key2];
						let char_name = { service_index:index, att_index:attributeIndex, name:key2 };
						char_name.type = descriptor.type ? descriptor.type: "";
						char_names.push(char_name);
						++attributeIndex;
					}
				}
			}
			file.line("");
			if (attributeCount > maxAttributeCount)
				maxAttributeCount = attributeCount;
			attributeCounts[index] = attributeCount;
		});
		file.line(`#define service_count ${services.length}`);
		file.line(`#define max_attribute_count ${maxAttributeCount}`);
		file.write(`static const uint8_t attribute_counts[${services.length}] = { `);
		file.write(buffer2hexlist(attributeCounts));
		file.write(" };");
		file.line("");
		file.line("");
		
		if (this.server) {
			file.line("int gatt_svr_chr_dynamic_value_access_cb(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg);");
			file.line("");
			let hasStaticCharacteristicValues = false;
			services.forEach((service, index) => {
				let characteristics = service.characteristics;
				for (let key in characteristics) {
					let characteristic = characteristics[key];
					if ("value" in characteristic)
						hasStaticCharacteristicValues = true;
				}
			});
			if (hasStaticCharacteristicValues) {
				file.line("static int gatt_svr_chr_static_value_access_cb(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)");
				file.line("{");
				file.line("\tif (arg == NULL) return BLE_ATT_ERR_UNLIKELY;");
				file.line("");
				file.line("\tstatic_value value = *(static_value*)arg;");
				file.line(`\tint rc = os_mbuf_append(ctxt->om, value.value, value.length);`);
				file.line("\treturn rc == 0 ? 0 : BLE_ATT_ERR_INSUFFICIENT_RES;");
				file.line("}");
				file.line("");
			}
			else {
				file.line("static int gatt_svr_chr_static_value_access_cb(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)");
				file.line("{");
				file.line("\treturn 0;");
				file.line("}");
				file.line("");
			}
		}

		file.line(`static const struct ble_gatt_svc_def gatt_svr_svcs[] = {`);
		services.forEach((service, index) => {
			characteristicIndex = 0;
			file.line("\t{");
			
			file.line(`\t\t// Service ${service.uuid}`);
			file.line("\t\t.type = BLE_GATT_SVC_TYPE_PRIMARY,");
			file.line(`\t\t.uuid = &service${index}_uuid.u,`);
			file.line("\t\t.characteristics = (struct ble_gatt_chr_def[])");
			file.line("\t\t{");
			let characteristics = service.characteristics;
			for (let key in characteristics) {
				descriptorIndex = 0;
				let characteristic = characteristics[key];
				file.line("\t\t\t{")
				file.line(`\t\t\t\t.uuid = &service${index}_chr${characteristicIndex}_uuid.u,`);
				if (this.server) {
					if ("value" in characteristic)
						file.line("\t\t\t\t.access_cb = gatt_svr_chr_static_value_access_cb,");
					else
						file.line("\t\t\t\t.access_cb = gatt_svr_chr_dynamic_value_access_cb,");
				}
				else
					file.line("\t\t\t\t.access_cb = NULL,");
				let flags = this.parseAccess(characteristic.permissions.split(","), characteristic.properties.split(","));
				file.line(`\t\t\t\t.flags = ${flags},`);
				if (this.server) {
					if ("value" in characteristic) {
						file.line(`\t\t\t\t.arg = &service${index}_chr${characteristicIndex}_value_struct,`);
					} else {
						file.line(`\t\t\t\t.arg = NULL,`);
					}
					file.line(`\t\t\t\t.val_handle = &service${index}_chr${characteristicIndex}_handle,`);
				}
				
				if (characteristic._descriptors) {
					file.line("\t\t\t\t.descriptors = (struct ble_gatt_dsc_def[])");
					file.line("\t\t\t\t{");
					let descriptors = characteristic.descriptors;
					for (let key2 in descriptors) {
						let descriptor = descriptors[key2];
						if ((undefined === descriptor.permissions) && this.client)
							descriptor.permissions = "read";
						if ((undefined === descriptor.properties) && this.client)
							descriptor.properties = "read";
						file.line("\t\t\t\t\t{")
						file.line(`\t\t\t\t\t\t.uuid = &service${index}_chr${characteristicIndex}_dsc${descriptorIndex}_uuid.u,`);
						if (this.server) {
							if ("value" in descriptor) {
								file.line("\t\t\t\t\t\t.access_cb = gatt_svr_chr_static_value_access_cb,");
								file.line(`\t\t\t\t\t\t.arg = &service${index}_chr${characteristicIndex}_dsc${descriptorIndex}_value_struct,`);
							} else {
								file.line("\t\t\t\t\t\t.access_cb = gatt_svr_chr_dynamic_value_access_cb,");
								file.line(`\t\t\t\t\t\t.arg = NULL,`);
							}
						}
						else
							file.line("\t\t\t\t\t\t.access_cb = NULL,");
						let flags = this.parseAccess(descriptor.permissions.split(","), descriptor.properties.split(","), "descriptor");
						file.line(`\t\t\t\t\t\t.att_flags = ${flags},`);
						file.line("\t\t\t\t\t},")
						++descriptorIndex;
					}
					file.line("\t\t\t\t\t{")
					file.line("\t\t\t\t\t\t0,")
					file.line("\t\t\t\t\t},")
					file.line("\t\t\t\t}");
				}
				file.line("\t\t\t},");
				++characteristicIndex;
			}
			file.line("\t\t\t{")
			file.line("\t\t\t\t0,")
			file.line("\t\t\t},")
			file.line("\t\t}");
			file.line("\t},");
		});
		file.line("\t{");
		file.line("\t\t0,")
		file.line("\t}")
		file.line("};");
		file.line("");
		
		file.line(`#define char_name_count ${char_names.length}`);
		file.line(`static const char_name_table char_names[${char_names.length}] = {`);
		char_names.forEach(entry => {
			file.line(`\t{${entry.service_index}, ${entry.att_index}, "${entry.name}", "${entry.type}"},`);
		});
		file.line("};");
		file.line("");
	}
	parseAccess(permissions, properties, type="characteristic") {
		const BLE_GATT_CHR_F_BROADCAST = 0x0001;
		const BLE_GATT_CHR_F_READ = 0x0002;
		const BLE_GATT_CHR_F_WRITE_NO_RSP = 0x0004;
		const BLE_GATT_CHR_F_WRITE = 0x0008;
		const BLE_GATT_CHR_F_NOTIFY = 0x0010;
		const BLE_GATT_CHR_F_INDICATE = 0x0020;
		const BLE_GATT_CHR_F_AUTH_SIGN_WRITE = 0x0040;
		const BLE_GATT_CHR_F_RELIABLE_WRITE = 0x0080;
		const BLE_GATT_CHR_F_AUX_WRITE = 0x0100;
		const BLE_GATT_CHR_F_READ_ENC = 0x0200;
		const BLE_GATT_CHR_F_READ_AUTHEN = 0x0400;
		const BLE_GATT_CHR_F_READ_AUTHOR = 0x0800;
		const BLE_GATT_CHR_F_WRITE_ENC = 0x1000;
		const BLE_GATT_CHR_F_WRITE_AUTHEN = 0x2000;
		const BLE_GATT_CHR_F_WRITE_AUTHOR = 0x4000;

		const BLE_GATT_DESC_F_READ = 0x01;
		const BLE_GATT_DESC_F_WRITE = 0x02;
		const BLE_GATT_DESC_F_READ_ENC = 0x04;
		const BLE_GATT_DESC_F_READ_AUTHEN = 0x08;
		const BLE_GATT_DESC_F_READ_AUTHOR = 0x10;
		const BLE_GATT_DESC_F_WRITE_ENC = 0x20;
		const BLE_GATT_DESC_F_WRITE_AUTHEN = 0x40;
		const BLE_GATT_DESC_F_WRITE_AUTHOR = 0x80;

		const isCharacteristic = (type == "characteristic");

		let flags = 0;
		properties.forEach(p => {
			switch(p.trim()) {
				case "read":
					flags |= (isCharacteristic ? BLE_GATT_CHR_F_READ : BLE_GATT_DESC_F_READ);
					break;
				case "write":
					flags |= (isCharacteristic ? BLE_GATT_CHR_F_WRITE : BLE_GATT_DESC_F_WRITE);
					break;
				case "writeNoResponse":
					flags |= BLE_GATT_CHR_F_WRITE_NO_RSP;
					break;
				case "notify":
					flags |= BLE_GATT_CHR_F_NOTIFY;
					break;
				case "indicate":
					flags |= BLE_GATT_CHR_F_INDICATE;
					break;
				case "extended":
					flags |= BLE_GATT_CHR_F_AUX_WRITE;
					break;
				default:
					throw new Error("unknown property");
			}
		});
		let readPerms = 0;
		let writePerms = 0;
		permissions.forEach(p => {
			switch(p.trim()) {
				case "read":
					++readPerms;
					flags |= (isCharacteristic ? BLE_GATT_CHR_F_READ : BLE_GATT_DESC_F_READ);
					break;
				case "readEncrypted":
					++readPerms;
					flags |= (isCharacteristic ? BLE_GATT_CHR_F_READ_ENC : BLE_GATT_DESC_F_READ_ENC);
					break;
				case "write":
					++writePerms;
					flags |= (isCharacteristic ? BLE_GATT_CHR_F_WRITE : BLE_GATT_DESC_F_WRITE);
					break;
				case "writeEncrypted":
					++writePerms;
					flags |= (isCharacteristic ? BLE_GATT_CHR_F_WRITE_ENC : BLE_GATT_DESC_F_WRITE_ENC);
					break;
				default:
					throw new Error("unsupported permission");
			}
		});
		if (readPerms > 1)
			throw new Error("only one of read/readEncrypted can be specified");
		if (writePerms > 1)
			throw new Error("only one of write/writeEncrypted can be specified");
		if (!isCharacteristic && flags > 0xFF)
			throw new Error("characteristic properties cannot be applied to descriptors");
		return flags;
	}
};

class QCA4020GATTFile extends GATTFile {
	generate() {
		let tool = this.tool;
		let file = this.file;
		let services = this.services;
		file.line('/* WARNING: This file is automatically generated. Do not edit. */');
		file.line("");
		file.line("typedef struct {");
		file.line("\tuint8_t service_index;");
		file.line("\tuint8_t att_index;");
		file.line("\tuint8_t encrypted;");
		file.line("\tconst char *name;");
		file.line("\tconst char *type;");
		file.line("} char_name_table;");
		file.line("");
		if (0 == services.length) {
			file.line("#define service_count 0");
			file.line("#define char_name_count 0");
			file.line("#define max_attribute_count 0");
			file.line("");
			file.line("static qapi_BLE_GATT_Service_Attribute_Entry_t ServiceTable[0][0] = {};");
			file.line("static const uint8_t attribute_counts[0] = {};");
			file.line("static const char_name_table char_names[0] = {};");
			return;
		}
		var attributeIndex = 0;
		var char_names = [];
		var maxAttributeCount = 0;
		var attributeCounts = new Array(services.length);
		var characteristicIndex = 0;
		var did_cccd = 0;

		services.forEach((service, index) => {
			let attributeCount = 1;
			let characteristics = service.characteristics;
			attributeCount += (Object.keys(characteristics).length * 2);
			for (let key in characteristics) {
				let characteristic = characteristics[key];
				if ((undefined === characteristic.permissions) && this.client)
					characteristic.permissions = "read";
				if ((undefined === characteristic.properties) && this.client)
					characteristic.properties = "read";
				let properties = characteristic.properties;
				if (properties.includes("notify") || properties.includes("indicate")) {
					++attributeCount;
					characteristic._notify = true;
					if (!did_cccd) {
						did_cccd = true;
						file.line("static qapi_BLE_GATT_Characteristic_Descriptor_16_Entry_t cccd = {{0x02, 0x29}, 2, NULL};");
						file.line("");
					}
				}
			}
			if (attributeCount > maxAttributeCount)
				maxAttributeCount = attributeCount;
			attributeCounts[index] = attributeCount;
			if (4 == service.uuid.length) {
				file.write(`static qapi_BLE_GATT_Primary_Service_16_Entry_t service${index} = {{`);
				file.write(buffer2hexlist(uuid16toBuffer(parseInt(service.uuid, 16))));
				file.write("}};");

			}
			else {
				file.write(`static qapi_BLE_GATT_Primary_Service_128_Entry_t service${index} = {{`);
				file.write(buffer2hexlist(uuid128toBuffer(service.uuid)));
				file.write("}};");
			}
			file.line("");
			file.line("");
			
			for (let key in characteristics) {
				let characteristic = characteristics[key];
				let uuid = characteristic.uuid;
				let properties = this.parseProperties(characteristic.properties.split(","));
				if (4 == uuid.length) {
					file.write(`static qapi_BLE_GATT_Characteristic_Declaration_16_Entry_t characteristic${characteristicIndex} = {`);
					file.write(`${properties}, {`);
					file.write(buffer2hexlist(uuid16toBuffer(parseInt(uuid, 16))));
					file.write("}};");
					file.line("");
				}
				else {
					file.write(`static qapi_BLE_GATT_Characteristic_Declaration_128_Entry_t characteristic${characteristicIndex} = {`);
					file.write(`${properties}, {`);
					file.write(buffer2hexlist(uuid128toBuffer(uuid)));
					file.write("}};");
					file.line("");
				}
				
				if ("value" in characteristic) {
					let buffer = typedValueToBuffer(characteristic.type, characteristic.value);
					characteristic._length = buffer.byteLength;
					file.write(`static uint8_t char_value_buffer${characteristicIndex}[${buffer.byteLength}] = { `);
					file.write(buffer2hexlist(buffer));
					file.write(" };");
					file.line("");
					if (4 == uuid.length) {
						file.write(`static qapi_BLE_GATT_Characteristic_Value_16_Entry_t char_value${characteristicIndex} = {{`);
						file.write(buffer2hexlist(uuid16toBuffer(parseInt(uuid, 16))));
						file.write(`}, ${characteristic._length}, char_value_buffer${characteristicIndex}`);
						file.write(" };");
					}
					else {
						file.write(`static qapi_BLE_GATT_Characteristic_Value_128_Entry_t char_value${characteristicIndex} = {{`);
						file.write(buffer2hexlist(uuid128toBuffer(uuid)));
						file.write(`}, ${characteristic._length}, char_value_buffer${characteristicIndex}`);
						file.write(" };");					
					}
				}
				else {
					let maxBytes;
					if (this.server && !this.client)
						maxBytes = characteristic.maxBytes;
					else
						maxBytes = ("maxBytes" in characteristic ? characteristic.maxBytes : 0);
					if (4 == uuid.length) {
						file.write(`static qapi_BLE_GATT_Characteristic_Value_16_Entry_t char_value${characteristicIndex} = {{`);
						file.write(buffer2hexlist(uuid16toBuffer(parseInt(uuid, 16))));
						file.write(`}, ${maxBytes}, NULL`);
						file.write(" };");
					}
					else {
						file.write(`static qapi_BLE_GATT_Characteristic_Value_128_Entry_t char_value${characteristicIndex} = {{`);
						file.write(buffer2hexlist(uuid128toBuffer(uuid)));
						file.write(`}, ${maxBytes}, NULL`);
						file.write(" };");					
					}
				}
				file.line("");
				++characteristicIndex;
			}
		});
		characteristicIndex = 0;
		
		file.line(`#define service_count ${services.length}`);
		file.line(`#define max_attribute_count ${maxAttributeCount}`);
		file.write(`static const uint8_t attribute_counts[${services.length}] = { `);
		file.write(buffer2hexlist(attributeCounts));
		file.write(" };");
		file.line("");

		file.line(`static qapi_BLE_GATT_Service_Attribute_Entry_t ServiceTable[${services.length}][${maxAttributeCount}] = {`);
		services.forEach((service, index) => {
			attributeIndex = 0;
			file.line("\t{");
			
			// primary service attribute
			let uuid = service.uuid;
			file.line(`\t\t// Service ${uuid}`);
			file.line("\t\t[", attributeIndex, "] = {");
			file.line("\t\t\tQAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,");
			if (4 == uuid.length)
				file.line("\t\t\tQAPI_BLE_AET_PRIMARY_SERVICE_16_E,");
			else
				file.line("\t\t\tQAPI_BLE_AET_PRIMARY_SERVICE_128_E,");
			file.line(`\t\t\t(void*)&service${index},`);
			file.line("\t\t},");
			++attributeIndex;
			
			let characteristics = service.characteristics;
			for (let key in characteristics) {
				let characteristic = characteristics[key];
				let uuid = characteristic.uuid;
				let encrypted = this.isEncrypted(characteristic);
				
				// characteristic declaration
				file.line("\t\t[", attributeIndex, "] = {");
				file.line("\t\t\tQAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE,");
				if (4 == uuid.length)
					file.line("\t\t\tQAPI_BLE_AET_CHARACTERISTIC_DECLARATION_16_E,");
				else
					file.line("\t\t\tQAPI_BLE_AET_CHARACTERISTIC_DECLARATION_128_E,");
				file.line(`\t\t\t(void*)&characteristic${characteristicIndex},`);
				file.line("\t\t},");
				++attributeIndex;

				// characteristic value
				let permissions = this.parsePermissions(characteristic.permissions.split(","));
				file.line("\t\t[", attributeIndex, "] = {");
				file.line(`\t\t\t${permissions},`);
				if (4 == uuid.length)
					file.line("\t\t\tQAPI_BLE_AET_CHARACTERISTIC_VALUE_16_E,");
				else
					file.line("\t\t\tQAPI_BLE_AET_CHARACTERISTIC_VALUE_128_E,");
				file.line(`\t\t\t(void*)&char_value${characteristicIndex},`);
				file.line("\t\t},");
				
				let char_name = { service_index:index, att_index:attributeIndex, encrypted, name:key };
				char_name.type = characteristic.type ? characteristic.type: "";
				char_names.push(char_name);

				++attributeIndex;
				
				// characteristic configuration descriptor
				if (characteristic._notify) {
					file.line("\t\t[", attributeIndex, "] = {");
					file.line("\t\t\tQAPI_BLE_GATT_ATTRIBUTE_FLAGS_WRITABLE,");
					file.line("\t\t\tQAPI_BLE_AET_CHARACTERISTIC_DESCRIPTOR_16_E,");
					file.line("\t\t\t(void*)&cccd,");
					file.line("\t\t},");
					++attributeIndex;
				}
				++characteristicIndex;
			}
			file.line("\t},");
		});
		file.line("};");
		file.line("");
		
		file.line(`#define char_name_count ${char_names.length}`);
		file.line(`static const char_name_table char_names[${char_names.length}] = {`);
		char_names.forEach(entry => {
			file.line(`\t{${entry.service_index}, ${entry.att_index}, ${entry.encrypted}, "${entry.name}", "${entry.type}"},`);
		});
		file.line("};");
		file.line("");
	}
	parseProperties(properties) {
		let props = [];
		properties.forEach(p => {
			switch(p.trim()) {
				case "read":
					props.push("QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_READ");
					break;
				case "write":
					props.push("QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE");
					break;
				case "writeNoResponse":
					props.push("QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_WRITE_WITHOUT_RESPONSE");
					break;
				case "notify":
					props.push("QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_NOTIFY");
					break;
				case "indicate":
					props.push("QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_INDICATE");
					break;
				case "extended":
					props.push("QAPI_BLE_GATT_CHARACTERISTIC_PROPERTIES_EXTENDED_PROPERTIES");
					break;
				default:
					throw new Error("unknown property");
			}
		});
		return props.join('|');
	}
	parsePermissions(permissions) {
		let perms = [];
		let readPerms = 0;
		let writePerms = 0;
		permissions.forEach(p => {
			switch(p.trim()) {
				case "read":
					++readPerms;
					perms.push("QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE");
					break;
				case "readEncrypted":
					++readPerms;
					perms.push("QAPI_BLE_GATT_ATTRIBUTE_FLAGS_READABLE");
					break;
				case "write":
					++writePerms;
					perms.push("QAPI_BLE_GATT_ATTRIBUTE_FLAGS_WRITABLE");
					break;
				case "writeEncrypted":
					++writePerms;
					perms.push("QAPI_BLE_GATT_ATTRIBUTE_FLAGS_WRITABLE");
					break;
				default:
					throw new Error("unsupported permission");
			}
		});
		if (readPerms > 1)
			throw new Error("only one of read/readEncrypted can be specified");
		if (writePerms > 1)
			throw new Error("only one of write/writeEncrypted can be specified");
		return perms.join('|');
	}
	isEncrypted(characteristic) {
		let encrypted = (-1 != characteristic.permissions.indexOf("readEncrypted") || -1 != characteristic.permissions.indexOf("writeEncrypted"));	
		return encrypted ? 1 : 0;
	}
};

class GeckoGATTFile extends GATTFile {
	generate() {
		let file = this.file;
		let services = this.services;
		let clientOnly = (this.client && !this.server);
		file.line('/* WARNING: This file is automatically generated. Do not edit. */');
		file.line('');
		if (!clientOnly) {
			file.line('#include "bg_gattdb_def.h"');
			file.line('');
			file.line('#ifdef __GNUC__');
			file.line('\t#define GATT_HEADER(F) F __attribute__ ((section (".gatt_header")))');
			file.line('\t#define GATT_DATA(F) F __attribute__ ((section (".gatt_data")))');
			file.line('#else');
			file.line('\t#ifdef __ICCARM__');
			file.line('\t\t#define GATT_HEADER(F) _Pragma("location=\\".gatt_header\\"") F');
			file.line('\t\t#define GATT_DATA(F) _Pragma("location=\\".gatt_data\\"") F');
			file.line('\t#else');
			file.line('\t\t#define GATT_HEADER(F) F');
			file.line('\t\t#define GATT_DATA(F) F');
			file.line('\t#endif');
			file.line('#endif');
			file.line('');
		}
		file.line("typedef struct {");
		file.line("\tuint16_t handle;");
		file.line("\tuint8_t uuid[16];");
		file.line("\tuint16_t uuid_length;");
		file.line("\tconst char *name;");
		file.line("\tconst char *type;");
		file.line("} char_name_table;");
		file.line("");
		let char_names = [];
		let uuidtable_16_map = ["0x2800","0x2801","0x2803"];
		let uuidtable_128_map = [];
		let dynamic_mapping_map = [];
		let attributes_max = services.length;
		let attributes_dynamic_max = 0;
		let needs_cccd = true;
		services.forEach((service, index) => {
			if (4 != service.uuid.length)
				throw new Error("128-bit UUIDs not supported");
			uuidtable_16_map.push('0x' + service.uuid);
			let characteristics = service.characteristics;
			let length = Object.keys(characteristics).length;
			attributes_max += (length * 2);
			for (let key in characteristics) {
				let characteristic = characteristics[key];
				if ((undefined === characteristic.permissions) && this.client)
					characteristic.permissions = "read";
				if ((undefined === characteristic.properties) && this.client)
					characteristic.properties = "read";
				if (!characteristic.hasOwnProperty("value"))
					attributes_dynamic_max += 1;
				if (4 != characteristic.uuid.length)
					throw new Error("128-bit UUIDs not supported");
				uuidtable_16_map.push('0x' + characteristic.uuid);
				let properties = characteristic.properties;
				if (properties.includes("notify") || properties.includes("indicate")) {
					++attributes_max;
					characteristic._flags = properties.includes("notify") ? 1 : 2;
					if (needs_cccd) {
						uuidtable_16_map.push('0x2902');
						needs_cccd = false;
					}
				}
			}
		});
		if (!clientOnly) {
			file.line("GATT_DATA(const uint16_t bg_gattdb_data_uuidtable_16_map[]) = {");
			file.write('\t' + uuidtable_16_map.join(','));
			file.line('');
			file.line("};")
			file.line("GATT_DATA(const uint8_t bg_gattdb_data_uuidtable_128_map[]) = {0x00};");
			file.line('');
			file.line("GATT_DATA(const uint8_t bg_gattdb_data_adv_uuid16_map[]) = {0x00};");
			file.line("GATT_DATA(const uint8_t bg_gattdb_data_adv_uuid128_map[]) = {0x00};");
			file.line('');
		}
		let field_index = 0;
		let clientconfig_index = 0;
		let index = 0;
		let buffer;
		
		services.forEach((service) => {
			buffer = uuid16toBuffer(parseInt(service.uuid, 16));
			
			// service
			if (!clientOnly) {
				file.line(`GATT_DATA(const struct bg_gattdb_buffer_with_len bg_gattdb_data_attribute_field_${field_index}) = {`);
				file.line(`\t.len = ${buffer.byteLength},`);
				file.write('\t.data = {');
				file.write(buffer2hexlist(buffer));
				file.write('}');
				file.line('');
				file.line('};');
			}
			++field_index;
			let characteristics = service.characteristics;
			for (let key in characteristics) {
				let characteristic = characteristics[key];
				let uuid = parseInt(characteristic.uuid, 16);
				let data = new Uint8Array(5);
				let properties = this.parseProperties(characteristic.properties.split(","));
				data[0] = properties;
				data[1] = (field_index + 2) & 0xFF;
				data[2] = ((field_index + 2) >> 8) & 0xFF;
				data[3] = uuid & 0xFF;
				data[4] = (uuid >> 8) & 0xFF;
				
				// characteristic declaration
				if (!clientOnly) {
					file.line(`GATT_DATA(const struct bg_gattdb_buffer_with_len bg_gattdb_data_attribute_field_${field_index}) = {`);
					file.line(`\t.len = ${data.buffer.byteLength},`);
					file.write('\t.data = {');
					file.write(buffer2hexlist(data.buffer));
					file.write('}');
					file.line('');
					file.line('};');
				}
				dynamic_mapping_map.push('0x' + parseInt(field_index + 2).toString(16));
				++field_index;

				// characteristic value
				let maxBytes;
				if (this.server && !this.client)
					maxBytes = characteristic.maxBytes;
				else
					maxBytes = ("maxBytes" in characteristic ? characteristic.maxBytes : 0);
				if (characteristic.hasOwnProperty("value")) {
					buffer = typedValueToBuffer(characteristic.type, characteristic.value);
					if (!clientOnly) {
						file.write(`uint8_t bg_gattdb_data_attribute_field_${field_index}_data[${maxBytes}] = {`);
						file.write(buffer2hexlist(buffer));
						file.write('};');
						file.line('');
					}
				}
				else {
					let char_name = { handle:field_index + 1, name:key };
					char_name.uuid = (4 == characteristic.uuid.length ? uuid16toBuffer(parseInt(characteristic.uuid, 16)): uuid128toBuffer(characteristic.uuid));
					char_name.uuid = `{${buffer2hexlist(char_name.uuid)}}`;
					char_name.uuid_length = (4 == characteristic.uuid.length ? 2 : 16);
					char_name.type = characteristic.type ? characteristic.type: "";
					char_names.push(char_name);
				}
				if (!clientOnly) {
					file.line(`GATT_DATA(const struct bg_gattdb_attribute_chrvalue bg_gattdb_data_attribute_field_${field_index}) = {`);
					file.line(`\t.properties = 0x${properties.toString(16)},`);
					file.line(`\t.index = ${index},`);
					if (characteristic.hasOwnProperty("value")) {
						file.line(`\t.max_len = ${maxBytes},`);
						file.line(`\t.data = bg_gattdb_data_attribute_field_${field_index}_data`);
					}
					else {
						file.line(`\t.max_len = 0,`);
						file.line(`\t.data = NULL`);
					}
					file.line('};');
				}
				field_index += characteristic._flags ? 2 : 1;
				++index;
			}
		});
		if (!clientOnly) {
			file.line("GATT_DATA(const uint16_t bg_gattdb_data_attributes_dynamic_mapping_map[]) = {");
			file.write('\t' + dynamic_mapping_map.join(','));
			file.line('');
			file.line("};")
			file.line('');

			let _uuid = 2;
			field_index = 0;
			file.line('GATT_DATA(const struct bg_gattdb_attribute bg_gattdb_data_attributes_map[]) = {');
			services.forEach((service) => {
				file.line(`\t{.uuid = 0x00, .permissions = 0x801, .caps = 0xFFFF, .datatype = 0x00, .min_key_size = 0x00, .constdata = &bg_gattdb_data_attribute_field_${field_index}},`);
				++_uuid;
				++field_index;
				let characteristics = service.characteristics;
				for (let key in characteristics) {
					let characteristic = characteristics[key];
					file.line(`\t{.uuid = 0x02, .permissions = 0x801, .caps = 0xFFFF, .datatype = 0x00, .min_key_size = 0x00, .constdata = &bg_gattdb_data_attribute_field_${field_index}},`);
					++field_index;
					++_uuid;
					let datatype = (characteristic.hasOwnProperty("value") ? 1 : 7);
					let permissions = characteristic._flags ? "0x800" : "0x" + this.parsePermissions(characteristic.permissions.split(",")).toString(16);
					file.line(`\t{.uuid = ${toPaddedHex(_uuid)}, .permissions = ${permissions}, .caps = 0xFFFF, .datatype = ${toPaddedHex(datatype)}, .min_key_size = 0x00, .dynamicdata = &bg_gattdb_data_attribute_field_${field_index}},`);
					++field_index;
					if (characteristic._flags) {
						let index = dynamic_mapping_map.findIndex(element => field_index == parseInt(element, 16));
						++_uuid;
						file.line(`\t{.uuid = ${toPaddedHex(_uuid)}, .permissions = 0x807, .caps = 0xFFFF, .datatype = 0x03, .min_key_size = 0x00, .configdata = {.flags = ${toPaddedHex(characteristic._flags)}, .index = ${toPaddedHex(index)}, .clientconfig_index = ${toPaddedHex(clientconfig_index)}}},`);
						++field_index;
						++clientconfig_index;
					}
				}
			});
			file.line('};');
			file.line('');
			file.line('GATT_HEADER(const struct bg_gattdb_def bg_gattdb_data) = {');
			file.line('\t.attributes = bg_gattdb_data_attributes_map,');
			file.line(`\t.attributes_max = ${attributes_max},`);
			file.line(`\t.uuidtable_16_size = ${uuidtable_16_map.length},`);
			file.line('\t.uuidtable_16 = bg_gattdb_data_uuidtable_16_map,');
			file.line(`\t.uuidtable_128_size = ${uuidtable_128_map.length},`);
			file.line('\t.uuidtable_128 = bg_gattdb_data_uuidtable_128_map,');
			file.line(`\t.attributes_dynamic_max = ${attributes_dynamic_max},`);
			file.line('\t.attributes_dynamic_mapping = bg_gattdb_data_attributes_dynamic_mapping_map,');
			file.line('\t.adv_uuid16 = bg_gattdb_data_adv_uuid16_map,');
			file.line('\t.adv_uuid16_num = 0,');
			file.line('\t.adv_uuid128 = bg_gattdb_data_adv_uuid128_map,');
			file.line('\t.adv_uuid128_num = 0,');
			file.line('\t.caps_mask = 0xffff,');
			file.line('\t.enabled_caps = 0xffff');
			file.line('};');
			file.line('');
		}
		file.line(`#define char_name_count ${char_names.length}`);
		file.line(`static const char_name_table char_names[${char_names.length}] = {`);
		char_names.forEach(entry => {
			file.line(`\t{${entry.handle}, ${entry.uuid}, ${entry.uuid_length}, "${entry.name}", "${entry.type}"},`);
		});
		file.line("};");
		file.line("");		
	}
	parseProperties(properties) {
		const gatt_char_prop_read = 0x02;
		const gatt_char_prop_writenoresp  = 0x04;
		const gatt_char_prop_write = 0x08;
		const gatt_char_prop_notify = 0x10;
		const gatt_char_prop_indicate = 0x20;
		const gatt_char_prop_writesign = 0x40;
		const gatt_char_prop_extended = 0x80;
		let props = 0;
		properties.forEach(p => {
			switch(p.trim()) {
				case "read":
					props |= gatt_char_prop_read;
					break;
				case "write":
					props |= gatt_char_prop_write;
					break;
				case "writeNoResponse":
					props |= gatt_char_prop_writenoresp;
					break;
				case "notify":
					props |= gatt_char_prop_notify;
					break;
				case "indicate":
					props |= gatt_char_prop_indicate;
					break;
				case "extended":
					props |= gatt_char_prop_extended;
					break;
				default:
					throw new Error("unknown property");
			}
		});
		return props;
	}
	parsePermissions(permissions) {
		const gatt_att_perm_readable = 0x0001;
		const gatt_att_perm_writable = 0x0002;
		const gatt_att_perm_write_no_response = 0x0004;
		const gatt_att_perm_encrypted_read = 0x0010;
		const gatt_att_perm_encrypted_write = 0x0100;
		const gatt_att_perm_discoverable = 0x0800;
		let perms = gatt_att_perm_discoverable;
		let readPerms = 0;
		let writePerms = 0;
		permissions.forEach(p => {
			switch(p.trim()) {
				case "read":
					++readPerms;
					perms |= gatt_att_perm_readable;
					break;
				case "readEncrypted":
					++readPerms;
					perms |= gatt_att_perm_encrypted_read;
					break;
				case "write":
					++writePerms;
					perms |= gatt_att_perm_writable;
					break;
				case "writeEncrypted":
					++writePerms;
					perms |= gatt_att_perm_encrypted_write;
					break;
				default:
					throw new Error("unsupported permission");
			}
		});
		if (readPerms > 1)
			throw new Error("only one of read/readEncrypted can be specified");
		if (writePerms > 1)
			throw new Error("only one of write/writeEncrypted can be specified");
		return perms;
	}
};

export default class extends TOOL {
	constructor(argv) {
		super(argv);
		this.windows = this.currentPlatform == "win";
		this.slash = this.windows ? "\\" : "/";
		this.moddablePath = this.getenv("MODDABLE");
		this.name = null;
		this.outputPath = null;
		this.files = [];
		var argc = argv.length;
		var name, path;
		for (var argi = 1; argi < argc; argi++) {
			var option = argv[argi];
			switch (option) {
				case "-o":
					argi++;	
					if (argi >= argc)
						throw new Error("-o: no directory!");
					name = argv[argi];
					if (this.outputDirectory)
						throw new Error("-o '" + name + "': too many directories!");
					path = this.resolveDirectoryPath(name);
					if (!path)
						throw new Error("-o '" + name + "': directory not found!");
					this.outputPath = path;
					if (this.outputPath.includes('tmp/esp32') || this.outputPath.includes('tmp\\esp32'))
						this.platform = "esp32";
					else if (this.outputPath.includes('tmp/gecko') || this.outputPath.includes('tmp\\gecko'))
						this.platform = "gecko";
					else if (this.outputPath.includes('tmp/qca4020') || this.outputPath.includes('tmp\\qca4020'))
						this.platform = "qca4020";
					else
						throw new Error("unknown platform");
					break;
				case "-c":
					this.client = true;
					break;
				case "-v":
					this.server = true;
					break;
				case "-n":
					this.nimble = true;
					break;
				case "-s":
					argi++;	
					if (argi >= argc)
						throw new Error("-s: no sdkconfig!");
					this.sdkconfig = argv[argi];
					break;
				default:
					name = argv[argi];
					path = this.resolveFilePath(name);
					if (!path)
						throw new Error("'" + name + "': file not found!");
					this.files.push(path);
					break;
			}
		}
		if (!this.name)
			this.name = "mc.bleservices.c";
		if (!this.outputPath)
			this.outputPath = this.currentDirectory;
		if (!this.platform)
			this.platform = this.currentPlatform;
	}
	run() {
		var path = this.joinPath({directory: this.outputPath, name:this.name});
		var file = new FILE(path);
		var services = [];
		this.files.forEach((path, index) => {
			try {
				const parse = JSON.parse(this.readFileString(path));
				if (!parse.service)
					throw new Error("service property missing");
				const service = parse.service;
				if (!service.uuid)
					throw new Error("service.uuid property missing");
				if (!service.characteristics)
					throw new Error("service.characteristics property missing");
				services.push(service);
			}
			catch (e) {
				trace(`Error in JSON file ${path}\n`);
				throw e;
			}
		});
		var dictionary = { tool:this, client:this.client, server:this.server, nimble:this.nimble, file, services };
		var gatt;
		if ("esp32" == this.platform) {
			dictionary.sdkconfig = this.sdkconfig;
			if (this.nimble)
				gatt = new NimBLEGATTFile(dictionary);
			else
				gatt = new BluedroidGATTFile(dictionary);
		}
		else if ("gecko" == this.platform)
			gatt = new GeckoGATTFile(dictionary);
		else if ("qca4020" == this.platform)
			gatt = new QCA4020GATTFile(dictionary);
		gatt.generate();
		file.close();
	}
}

function buffer2hexlist(buffer) {
	let byteArray = new Uint8Array(buffer);
	let hexParts = [];
	for (let i = 0; i < byteArray.length; i++) {
		let hex = byteArray[i].toString(16);
		let padded = ("00" + hex).slice(-2);
		hexParts.push("0x" + padded);
	}
	return hexParts.join(", ");
}

function toPaddedHex(value) {
	return "0x" + ("00" + value.toString(16)).slice(-2);
}

function uuid128toBuffer(uuid128) {
	let uuid = uuid128.replace(/-/g,'');
	let array = new Uint8Array(16);
	for (let i = 0; i < 16; ++i)
		array[15 - i] = parseInt(uuid.slice(2 * i, 2 * i + 2), 16);
	return array.buffer;
}

function uuid16toBuffer(uuid16) {
	return (new Uint8Array([uuid16 & 0xFF, (uuid16 >> 8) & 0xFF])).buffer;
}

function typedValueToBuffer(type, value) {
	let buffer;
	switch(type) {
		case "Array":
		case "Uint8Array":
			buffer = new Uint8Array(value).buffer;
			break;
		case "String":
			buffer = ArrayBuffer.fromString(value);
			break;
		case "Uint8":
			buffer = new Uint8Array([value & 0xFF]).buffer;
			break;
		case "Uint16":
			buffer = new Uint8Array([value & 0xFF, (value >> 8) & 0xFF]).buffer;
			break;
		case "Uint32":
			buffer = new Uint8Array([value & 0xFF, (value >> 8) & 0xFF, (value >> 16) & 0xFF, (value >> 24) & 0xFF]).buffer;
			break;
		case "ArrayBuffer":
		default:
			buffer = value;
			break;
	}
	return buffer;
}
