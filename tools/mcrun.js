/*
 * Copyright (c) 2016-2017  Moddable Tech, Inc.
 *
 *   This file is part of the Moddable SDK Tools.
 * 
 *   The Moddable SDK Tools is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 * 
 *   The Moddable SDK Tools is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 * 
 *   You should have received a copy of the GNU General Public License
 *   along with the Moddable SDK Tools.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

import TOOL from "tool";
import * as FS from "fs";

class File {
	constructor(path) {
		this.fd = FS.openSync(path, "w");
		this.slash = "/";
	}
	close() {
		FS.closeSync(this.fd);
		delete this.fd;
	}
	line(...strings) {
		for (var string of strings)
			this.write(string);
		this.write("\n");
	}
	write(string) {
		FS.writeSync(this.fd, string);
	}
}

class MakeFile extends File {
	constructor(path) {
		super(path)
	}
	generate(tool) {
		this.line('# WARNING: This file is automatically generated by mcrun. Do not edit. #');
		if (tool.debug)
			this.line("DEBUG = 1");
		if (tool.verbose)
			this.line("VERBOSE = 1");
		this.line("TMP_DIR = ", tool.tmpPath);
		this.line("NAME = ", tool.moduleName);
	
		this.write(FS.readFileSync(tool.fragmentPath));
		this.line("");
		
		this.line("$(TMP_DIR)", tool.slash, tool.moduleName, ".xsb: ", tool.filePath);
		this.line("\t@echo \"# xsc ", tool.moduleName, ".xsb\"");
		if (tool.debug)
			this.line("\t$(XSC) ", tool.filePath, " -d -o $(@D) -r ", tool.moduleName);
		else
			this.line("\t$(XSC) ", tool.filePath, " -o $(@D) -r ", tool.moduleName);
			
		this.close();
	}
}

var platformNames = {
	esp: "esp",
	esp32: "esp32",
	ios: "ios",
	"ios-simulator": "ios",
	mac: "mac",
	zephyr: "zephyr",
};

export default class Tool extends TOOL {
	constructor(argv) {
		super(argv);
		
		this.moddablePath = this.getenv("MODDABLE");
		if (!this.moddablePath)
			throw new Error("MODDABLE: variable not found!");
		
		this.debug = false;
		this.filePath = null;
		this.make = false;
		this.moduleName = null;
		this.outputPath = null;
		this.platform = null;
		this.verbose = false;
		this.windows = this.currentPlatform == "win";
		this.slash = this.windows ? "\\" : "/";
		
		var name, path;
		var argc = argv.length;
		for (var argi = 1; argi < argc; argi++) {
			var option = argv[argi];
			switch (option) {
			case "-d":
				this.debug = true;
				break;
			case "-m":
				this.make = true;
				break;
			case "-n":
				argi++;	
				if (argi >= argc)
					throw new Error("-n: no name!");
				name = argv[argi];
				if (this.platform)
					throw new Error("-n '" + name + "': too many names!");
				this.moduleName = name;
				break;
			case "-o":
				argi++;	
				if (argi >= argc)
					throw new Error("-o: no directory!");
				name = argv[argi];
				if (this.outputPath)
					throw new Error("-o '" + name + "': too many directories!");
				path = this.resolveDirectoryPath(name);
				if (!path)
					throw new Error("-o '" + name + "': directory not found!");
				this.outputPath = path;
				break;
			case "-p":
				argi++;	
				if (argi >= argc)
					throw new Error("-p: no platform!");
				name = argv[argi];
				if (this.platform)
					throw new Error("-p '" + name + "': too many platforms!");
				name = name.toLowerCase();
				if (name in platformNames)
					name = platformNames[name];
				this.platform = name;
				break;
			case "-v":
				this.verbose = true;
				break;
			default:
				name = argv[argi];
				if (this.filePath)
					throw new Error("'" + name + "': too many files!");
				path = this.resolveFilePath(name);
				if (!path)
					throw new Error("'" + name + "': file not found!");
				this.filePath = path;
				break;
			}
		}
		if (this.filePath) {
			var parts = this.splitPath(this.filePath);
			this.currentDirectory = this.srcPath = parts.directory;
		}
		else {
			path = this.resolveFilePath("." + this.slash + "main.js");
			if (path)
				this.filePath = path;
			else
				throw new Error("no file!");
			this.srcPath = this.currentDirectory;
		}
		if (!this.moduleName) {
			var parts = this.splitPath(this.filePath);
			if (parts.name == "main") {
				parts = this.splitPath(parts.directory);
			}
			this.moduleName = parts.name;
		}
		if (!this.outputPath) {
			this.outputPath = this.moddablePath + this.slash + "build";
		}
		if (!this.platform)
			this.platform = this.currentPlatform;
		path = this.resolveFilePath(this.moddablePath + this.slash + "tools" + this.slash + "mcrun" + this.slash + "manifest." + this.platform + ".mk");
		if (!path)
			throw new Error("unknown platform!");
		this.fragmentPath = path;
	}
	createDirectories(path, first) {
		FS.mkdirSync(path);
		path += this.slash + first;
		FS.mkdirSync(path);
		path += this.slash + this.platform;
		if (this.debug) 
			path += this.slash + "debug";
		else
			path += this.slash + "release";
		FS.mkdirSync(path);
		var platform = this.platform;
		if ((platform == "mac") || (platform == "win") || (platform == "lin")) {
			path += this.slash + "mc";
			FS.mkdirSync(path);
		}
		path += this.slash + this.moduleName;
		FS.mkdirSync(path);
		return path;
	}
	run() {
		this.tmpPath = this.createDirectories(this.outputPath, "tmp");
		
		var path = this.tmpPath + this.slash + "makefile";
		var file = new MakeFile(path);
		file.generate(this);
		
		if (this.make) {
			if (this.windows)
				this.then("nmake", "/nologo", "/f", path);
			else
				this.then("make", "-f", path);
		}
	}
}

		
		
