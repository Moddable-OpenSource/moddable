/*
 * Copyright (c) 2016-2017  Moddable Tech, Inc.
 *
 *   This file is part of the Moddable SDK Tools.
 * 
 *   The Moddable SDK Tools is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 * 
 *   The Moddable SDK Tools is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 * 
 *   You should have received a copy of the GNU General Public License
 *   along with the Moddable SDK Tools.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

import TOOL from "tool";
import * as FS from "fs";

class File {
	constructor(path) {
		this.fd = FS.openSync(path, "w");
		this.slash = "/";
	}
	close() {
		FS.closeSync(this.fd);
		delete this.fd;
	}
	line(...strings) {
		for (var string of strings)
			this.write(string);
		this.write("\n");
	}
	write(string) {
		FS.writeSync(this.fd, string);
	}
}

class PrerequisiteFile {
	constructor(path) {
		this.path = path;
		this.former = FS.existsSync(path) ? FS.readFileSync(path) : "";
		this.current = ""
	}
	close() {
		if (this.former.compare(this.current))
			FS.writeFileSync(this.path, this.current);
	}
	line(...strings) {
		for (var string of strings)
			this.write(string);
		this.write("\n");
	}
	write(string) {
		this.current += string;
	}
}

var platformNames = {
	esp: "esp",
	esp32: "esp32",
	ios: "ios",
	"ios-simulator": "ios",
	mac: "mac",
	zephyr: "zephyr",
};

var formatNames = {
	gray16: "gray16",
	gray256: "gray256",
	rgb332: "rgb332",
	rgb565le: "rgb565le",
	rgb565be: "rgb565be",
	clut16: "clut16",
	x: "x",
};

var formatStrings = {
	gray16: "Gray16",
	gray256: "Gray256",
	rgb332: "RGB332",
	rgb565le: "RGB565LE",
	rgb565be: "RGB565BE",
	clut16: "CLUT16",
	x: "",
};

var formatValues = {
	gray16: 4,
	gray256: 5,
	rgb332: 6,
	rgb565le: 7,
	rgb565be: 8,
	clut16: 11,
	x: 0,
};

var resourceExtensions = [  
	".act", ".fnt", ".json", ".png", ".gif", ".jpg", ".jpeg", 
	".bmp", ".cct", ".nfnt", ".rle", ".ttf", ".zip", // copy
	".dat", ".der", ".pk8", ".ski", ".subject",
];

class MakeFile extends File {
	constructor(path) {
		super(path)
	}
	generate(tool) {
		this.generateDefinitions(tool)
		var path = tool.moddablePath + tool.slash + "tools" + tool.slash + "mcconfig" + tool.slash + "manifest." + tool.platform + "." + tool.currentPlatform + ".mk";
		if (!FS.existsSync(path)) {
			path = tool.moddablePath + tool.slash + "tools" + tool.slash + "mcconfig" + tool.slash + "manifest." + tool.platform + ".mk";
		}
		this.write(FS.readFileSync(path));
		this.line("");
		this.generateModulesRules(tool)
		this.generateIDsRules(tool)
		this.generateObjectsRules(tool)
		this.generateResourcesRules(tool)
		this.close();
	}
	generateDefinitions(tool) {
		this.line('# WARNING: This file is automatically generated by mcconfig. Do not edit. #');

		if (tool.debug)
			this.line("DEBUG = 1");
		if (tool.debug || tool.instrument)
			this.line("INSTRUMENT = 1");
		if (tool.verbose)
			this.line("VERBOSE = 1");
			
		for (var result in tool.environment)
			this.line(result, " = ", tool.environment[result].replace(/ /g, "\\ "));
			
		this.line("BUILD_DIR = ", tool.buildPath);
		this.line("XS_DIR = ", tool.xsPath);
		this.line("BIN_DIR = ", tool.binPath);
		this.line("TMP_DIR = ", tool.tmpPath);
		this.line("DATA_DIR = ", tool.dataPath);
		this.line("MODULES_DIR = ", tool.modulesPath);
		this.line("RESOURCES_DIR = ", tool.resourcesPath);
		this.line("MAIN_DIR = ", tool.mainPath);
		this.write("MANIFEST =");
		for (var result in tool.manifests.already) {
			this.write(" \\\n\t");
			this.write(result);
		}	
		this.line("");
		
		this.write("MODULES =");
		for (var result of tool.jsFiles) {
			this.write("\\\n\t$(MODULES_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}	
		for (var result of tool.cFiles) {
			var sourceParts = tool.splitPath(result.source);
			this.write("\\\n\t$(TMP_DIR)");
			this.write(tool.slash);
			this.write(sourceParts.name);
			this.write(".xsi");
		}
		this.line("");
		this.write("PRELOADS =");
		for (var result of tool.preloads) {
			this.write("\\\n\t-p ");
			this.write(result);
		}	
		this.line("");
		this.write("STRIPS =");
		if (tool.strip) {
			for (var result of tool.strip) {
				this.write("\\\n\t-s \"");
				this.write(result);
				this.write("\"");
			}
		}
		this.line("");

		var creation = tool.creation;
		this.line("CREATION = -c ", 
				creation.chunk.initial, ",", 
				creation.chunk.incremental, ",", 
				creation.heap.initial, ",", 
				creation.heap.incremental, ",", 
				creation.stack, ",", 
				creation.keys.available, ",", 
				creation.keys.name, ",", 
				creation.keys.symbol, ",",
				creation.static, ",", 
				creation.main);
		this.write("DATA =");
		for (var result of tool.dataFiles) {
			this.write("\\\n\t$(DATA_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}	
		this.line("");
		this.generateObjectsDefinitions(tool);
		this.generateResourcesDefinitions(tool);
	}
	generateIDsRules(tool) {
		for (var result of tool.cFiles) {
			var source = result.source;
			var sourceParts = tool.splitPath(result.source);
			this.line("$(TMP_DIR)", tool.slash, sourceParts.name, ".xsi: ", source);
			this.line("\t@echo \"# xsid ", sourceParts.name, ".xsi\"");
			this.line("\t$(XSID) ", source, " -o $(@D)");
		}
	}
	generateModulesRules(tool) {
		for (var result of tool.jsFiles) {
			var source = result.source;
			var sourceParts = tool.splitPath(source);
			var target = result.target;
			var targetParts = tool.splitPath(target);
			this.line("$(MODULES_DIR)", tool.slash, target, ": ", source);
			this.line("\t@echo \"# xsc ", target, "\"");
			if (result.commonjs) {
				if (tool.debug)
					this.line("\t$(XSC) ", source, " -m -e -d -c -o $(@D) -r ", targetParts.name);
				else
					this.line("\t$(XSC) ", source, " -m -e -c -o $(@D) -r ", targetParts.name);
			}
			else {
				if (tool.debug)
					this.line("\t$(XSC) ", source, " -e -d -c -o $(@D) -r ", targetParts.name);
				else
					this.line("\t$(XSC) ", source, " -e -c -o $(@D) -r ", targetParts.name);
			}
		}
	}
	generateObjectsDefinitions(tool) {
		this.write("DIRECTORIES =");
		for (var folder of tool.cFolders) {
			this.write("\\\n\t");
			if (tool.windows
				&& (tool.platform != "synergy")
				&& (tool.platform != "esp"))
				this.write("/I");
			else
				this.write("-I");
			this.write(folder);
		}	
		this.line("");
		if (tool.format)
			this.line("DISPLAY = ", formatValues[tool.format]);
		this.write("HEADERS =");
		for (var header of tool.hFiles) {
			this.write("\\\n\t");
			this.write(header);
		}	
		this.write("\\\n\t$(TMP_DIR)");
		this.write(tool.slash);
		this.write("mc.defines.h");
		if (tool.format) {
			this.write("\\\n\t$(TMP_DIR)");
			this.write(tool.slash);
			this.write("mc.format.h");
			this.write("\\\n\t$(TMP_DIR)");
			this.write(tool.slash);
			this.write("mc.rotation.h");
		}
		this.line("");
		this.write("OBJECTS =");
		for (var result of tool.cFiles) {
			this.write("\\\n\t$(TMP_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}	
		this.line("");
	}
	generateObjectsRules(tool) {
		for (var result of tool.cFiles) {
			var source = result.source;
			var target = result.target;
			this.line("$(TMP_DIR)/", target, ": ", source, " $(HEADERS) | $(TMP_DIR)/mc.xs.c");
			if (result.recipe) {
				this.write(tool.recipes[result.recipe]);
			}
			else {
				this.line("\t@echo \"# cc ", target, "\"");
				this.line("\t$(CC) $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) $< -o $@");
			}
		}
	}
	generateResourcesDefinitions(tool) {
		this.write("RESOURCES = $(STRINGS)");
		for (var result of tool.resourcesFiles) {
			this.write("\\\n\t$(RESOURCES_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}	
		if (tool.clutFiles) {
			for (var result of tool.clutFiles) {
				this.write("\\\n\t$(RESOURCES_DIR)");
				this.write(tool.slash);
				this.write(result.target);
			}	
		}	
		for (var result of tool.bmpColorFiles) {
			this.write("\\\n\t$(RESOURCES_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}	
		for (var result of tool.bmpAlphaFiles) {
			this.write("\\\n\t$(RESOURCES_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}	
		for (var result of tool.bmpFontFiles) {
			this.write("\\\n\t$(RESOURCES_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}	
		for (var result of tool.bmpMaskFiles) {
			this.write("\\\n\t$(RESOURCES_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}	
		for (var result of tool.imageFiles) {
			this.write("\\\n\t$(RESOURCES_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}	
		for (var result of tool.stringFiles) {
			this.write("\\\n\t$(RESOURCES_DIR)");
			this.write(tool.slash);
			this.write(result.target);
		}
		if (tool.stringFiles.length) {
			this.write("\\\n\t$(RESOURCES_DIR)");
			this.write(tool.slash);
			this.write("locals.mhi");
		}
		this.line("");
		this.line("ROTATION = ", tool.rotation);
		this.line("");
	}
	generateResourcesRules(tool) {
		var formatPath = "$(TMP_DIR)" + tool.slash + "mc.format.h";
		var rotationPath = "$(TMP_DIR)" + tool.slash + "mc.rotation.h";
	
		for (var result of tool.dataFiles) {
			var source = result.source;
			var target = result.target;
			this.line("$(DATA_DIR)", tool.slash, target, ": ", source);
			this.line("\t@echo \"# copy ", target, "\"");
			if (tool.windows)
				this.line("\tcopy /Y $** $@");
			else
				this.line("\tcp $< $@");
		}
	
		for (var result of tool.resourcesFiles) {
			var source = result.source;
			var target = result.target;
			this.line("$(RESOURCES_DIR)", tool.slash, target, ": ", source);
			this.line("\t@echo \"# copy ", target, "\"");
			if (tool.windows)
				this.line("\tcopy /Y $** $@");
			else
				this.line("\tcp $< $@");
		}
	
		if (tool.clutFiles) {
			for (var result of tool.clutFiles) {
				var source = result.source;
				var target = result.target;
				this.line("$(RESOURCES_DIR)", tool.slash, target, ": ", source);
				this.line("\t@echo \"# buildclut ", target, "\"");
				this.line("\t$(BUILDCLUT) ", source, " -o $(@D)");
			}
		}

		for (var result of tool.bmpAlphaFiles) {
			var target = result.target;
			if (result.colorFile)
				this.line("$(RESOURCES_DIR)", tool.slash, target, ": $(RESOURCES_DIR)", tool.slash, result.colorFile.target);
			else {
				var source = result.source;
				this.line("$(RESOURCES_DIR)", tool.slash, target, ": ", source, " ", rotationPath);
				this.line("\t@echo \"# png2bmp ", target, "\"");
				this.line("\t$(PNG2BMP) ", source, " -a -o $(@D) -r ", tool.rotation);
			}
		}
		
		for (var result of tool.bmpColorFiles) {
			var source = result.source;
			var target = result.target;
			var alphaTarget = result.alphaFile ? result.alphaFile.target : null;
			var clutSource = result.clutName ? "$(RESOURCES_DIR)" + tool.slash + result.clutName + ".cct" : null;
			this.write("$(RESOURCES_DIR)");
			this.write(tool.slash);
			this.write(target);
			this.write(": ");
			this.write(source);
			if (clutSource) {
				this.write(" ");
				this.write(clutSource);
			}
			this.write(" ");
			this.write(formatPath);
			this.write(" ");
			this.write(rotationPath);
			this.line("");
			this.write("\t@echo \"# png2bmp ");
			this.write(target);
			if (alphaTarget) {
				this.write(" ");
				this.write(alphaTarget);
			}
			this.line("\"");
			this.write("\t$(PNG2BMP) ");
			this.write(source);
			this.write(" -f ");
			this.write(tool.format);
			this.write(" -o $(@D) -r ");
			this.write(tool.rotation);
			if (!alphaTarget)
				this.write(" -c");
			if (clutSource) {
				this.write(" -clut ");
				this.write(clutSource);
			}
			this.line("");
		}
		
		for (var result of tool.bmpFontFiles) {
			var parts;
			var source = result.source;
			parts = tool.splitPath(source);
			parts.extension = ".png";
			var pngSource = tool.joinPath(parts);
			var target = result.target;
			parts = tool.splitPath(target);
			var bmpTarget = parts.name + "-alpha.bmp";
			var bmpSource = "$(RESOURCES_DIR)" + tool.slash + bmpTarget;
			this.line("$(RESOURCES_DIR)", tool.slash, target, ": ", source, " ", bmpSource, " ", rotationPath);
			this.line("\t@echo \"# compressbmf ", target, "\"");
			this.line("\t$(COMPRESSBMF) ", source, " -i ", bmpSource, " -o $(@D) -r ", tool.rotation);
			this.line(bmpSource, ": ", pngSource, " ", rotationPath);
			this.line("\t@echo \"# png2bmp ", bmpTarget, "\"");
			this.line("\t$(PNG2BMP) ", pngSource, " -a -o $(@D) -r ", tool.rotation, " -t");
		}

		for (var result of tool.bmpMaskFiles) {
			var parts;
			var source = result.source;
			var target = result.target;
			parts = tool.splitPath(target);
			var bmpTarget = parts.name + ".bmp";
			var bmpSource = "$(RESOURCES_DIR)" + tool.slash + bmpTarget;
			this.line("$(RESOURCES_DIR)", tool.slash, target, ": ", bmpSource);
			this.line("\t@echo \"# rle4encode ", target, "\"");
			this.line("\t$(RLE4ENCODE) ", bmpSource, " -o $(@D)");
			this.line(bmpSource, ": ", source, " ", rotationPath);
			this.line("\t@echo \"# png2bmp ", bmpTarget, "\"");
			this.line("\t$(PNG2BMP) ", source, " -a -o $(@D) -r ", tool.rotation, " -t");
		}
		
		for (var result of tool.imageFiles) {
			var source = result.source;
			var target = result.target;
			if (result.quality !== undefined) {
				var temporary = target + result.quality;
				this.line("$(RESOURCES_DIR)", tool.slash, temporary, ": ", source, " ", rotationPath);
				this.line("\t@echo \"# image2cs ", temporary, "\"");
				this.line("\t$(IMAGE2CS) ", source, " -o $(@D) -q ", result.quality, " -r ", tool.rotation);
				this.line("$(RESOURCES_DIR)", tool.slash, target, ": $(RESOURCES_DIR)", tool.slash, temporary);
				this.line("\t@echo \"# copy ", target, "\"");
				if (tool.windows)
					this.line("\tcopy /Y $** $@");
				else
					this.line("\tcp $< $@");
			}
			else {
				this.line("$(RESOURCES_DIR)", tool.slash, target, ": ", source, " ", rotationPath);
				this.line("\t@echo \"# image2cs ", target, "\"");
				this.line("\t$(IMAGE2CS) ", source, " -o $(@D) -r ", tool.rotation);
			}
		}
		
		for (var result of tool.stringFiles)
			this.line("$(RESOURCES_DIR)", tool.slash, result.target, ": ", "$(RESOURCES_DIR)", tool.slash, "locals.mhi");
		this.write("$(RESOURCES_DIR)");
		this.write(tool.slash);
		this.write("locals.mhi:");
		for (var result of tool.stringFiles) {
			this.write(" ");
			this.write(result.source);
		}
		this.line("");
		this.line("\t@echo \"# mclocal strings\"");
		this.write("\t$(MCLOCAL)");
		this.write(tool.windows ? " $**" : " $^");
		if (tool.debug)
			this.write(" -d");
		this.line(" -o $(@D) -s");
	}
}

class AndroidMakeFile extends MakeFile {
	constructor(path) {
		super(path)
	}
	generateObjectsDefinitions(tool) {
		this.line("SOURCES_DIR = ", tool.javaPath);
		this.write("SOURCES =");
		for (var result of tool.javaFiles) {
			var source = result.source;
			var buffer = FS.readFileSync(source);
			var a = buffer.match(/package ([^;]+);/m);
			if (a.length != 2) {
				throw new Error("no package in ", source);
			}
			a = a[1].split(".");
			var path = tool.javaPath;
			for (var name of a) {
				path += "/" + name;
				FS.mkdirSync(path);
			}			
			var parts = tool.splitPath(source);
			var target = a.join("/") + "/" + parts.name + ".java";
			this.write("\\\n\t$(SOURCES_DIR)/");
			this.write(target);
			result.target = target;
		}
		this.line("");
	}
	generateObjectsRules(tool) {
		for (var result of tool.javaFiles) {
			this.line("$(SOURCES_DIR)/", result.target, ": ", result.source);
			this.line("\t@echo \"# copy ", result.target, "\"");
			this.line("\tcp $< $@");
		}
	}
}

class NMakeFile extends MakeFile {
	constructor(path) {
		super(path)
	}
	generateObjectsRules(tool) {
		for (var result of tool.cFiles) {
			var source = result.source;
			var target = result.target;
			this.line("$(TMP_DIR)\\", target, ": ", source, " $(HEADERS)");
			if (result.recipe) {
				var recipe = tool.recipes[result.recipe];
				recipe = recipe.replace(/\$</g, source);
				this.write(recipe);
			}
			else {
				this.line("\t@echo # cl ", target);
				this.line("\tcl $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) ", source, " /Fo$@");
			}
		}
	}
}

class espNMakeFile extends NMakeFile {
	constructor(path) {
		super(path)
	}
	generateObjectsRules(tool) {
		for (var result of tool.cFiles) {
			var source = result.source;
			var target = result.target;
			this.line("$(TMP_DIR)\\", target, ": ", source, " $(HEADERS)");
			if (result.recipe) {
				var recipe = tool.recipes[result.recipe];
				recipe = recipe.replace(/\$</g, source);
				this.write(recipe);
			}
			else {
				this.line("\t@echo # cc ", target);
				//this.line("\t@echo # $(CC) $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) ", source, " -o $@");
				this.line("\t$(CC) $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) ", source, " -o $@");
				//this.line("\techo # $(AR) $(AR_OPTIONS) $(APP_ARCHIVE) $@");
				this.line("\t$(AR) $(AR_OPTIONS) $(APP_ARCHIVE) $@");
			}
		}
	}
}

class SynergyNMakeFile extends NMakeFile {
	constructor(path) {
		super(path)
	}
	generateObjectsRules(tool) {
		for (var result of tool.cFiles) {
			var source = result.source;
			var target = result.target;
			this.line("$(TMP_DIR)\\", target, ": ", source, " $(HEADERS)");
			if (result.recipe) {
				var recipe = tool.recipes[result.recipe];
				recipe = recipe.replace(/\$</g, source);
				this.write(recipe);
			}
			else {
				this.line("\t@echo # cc ", target);
				//this.line("\t@echo # $(CC) $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) ", source, " -o $@");
				this.line("\t$(CC) $(C_DEFINES) $(C_INCLUDES) $(C_FLAGS) ", source, " -o $@");
				//this.line("\techo # $(AR) $(AR_OPTIONS) $(ARCHIVE_FILE) $@");
				this.line("\t$(AR) $(AR_OPTIONS) $(ARCHIVE_FILE) $@");
			}
		}
	}
}

class CMakeListsFile extends PrerequisiteFile {
	constructor(path) {
		super(path);
	}
	generate(tool) {
		this.line("# MCCONFIG GENERATED FILE; DO NOT EDIT!");
		this.line("");
		this.line("cmake_minimum_required(VERSION 3.4.1)");
		this.line("");
		this.line("add_library(tech-moddable-piu SHARED");
		this.line("\t", tool.xsPath, "/platforms/android_xs.c");
		var names = FS.readDirSync(tool.xsPath + "/sources");
		var c = names.length;
		for (var i = 0; i < c; i++) {
			var name = names[i];
			if (name.endsWith(".c") && (name != "xsDefaults.c"))
				this.line("\t", tool.xsPath, "/sources/", name);
		}
		for (var result of tool.cFiles) {
			this.line("\t", result.source);
		}
		this.line("\t", tool.tmpPath, "/mc.xs.c");
		this.line(")");
		
		this.line("target_compile_definitions(tech-moddable-piu PUBLIC");
		this.line("\tINCLUDE_XSPLATFORM=1");
		this.line("\tXSPLATFORM=\"android_xs.h\"");
		this.line("\tmxDebug=1");
		this.line("\tmxRun=1");
		this.line("\tmxParse=1");
		this.line("\tmxNoFunctionLength=1");
		this.line("\tmxNoFunctionName=1");
		this.line("\tmxHostFunctionPrimitive=1");
		this.line("\tmxFewGlobalsTable=1");
		this.line(")");
		
		this.line("target_include_directories(tech-moddable-piu PUBLIC");
		this.line("\t", tool.xsPath, "/includes");
		this.line("\t", tool.xsPath, "/platforms");
		this.line("\t", tool.xsPath, "/sources");
		this.line("\t", tool.xsPath, "/sources/pcre");
		for (var folder of tool.cFolders) {
			this.line("\t", folder);
		}	
		this.line("\t", tool.tmpPath);
		this.line(")");

		this.line("target_link_libraries(tech-moddable-piu");
   		this.line("\tandroid");
		this.line("\tlog");
		this.line(")");

		this.close();
	}
}

class ConfigFile extends PrerequisiteFile {
	constructor(path) {
		super(path);
	}
	generate(tool) {
		this.line("/* MCCONFIG GENERATED FILE; DO NOT EDIT! */");
		this.line("");
		this.write("export default Object.freeze(");
		this.write(JSON.stringify(tool.config, null, "\t"));
		this.line(");");
		this.close();
	}
}

class DefinesFile extends PrerequisiteFile {
	constructor(path) {
		super(path);
	}
	generate(tool) {
		this.line("/* MCCONFIG GENERATED FILE; DO NOT EDIT! */");
		this.line("");
		this.generateDefines(tool, "MODDEF_", tool.defines)
		if (tool.platform == "x-lin") {
			this.line('#define PIU_DASH_SIGNATURE "', tool.environment.DASH_SIGNATURE, '"');
			this.line('#define PIU_DOT_SIGNATURE "', tool.environment.DOT_SIGNATURE, '"');
			this.line('#define PIU_SLASH_SIGNATURE "', tool.environment.SLASH_SIGNATURE, '"');
		}
		this.close();
	}
	generateDefines(tool, prefix, defines) {
		let name;

		for (name in defines) {
			let value = defines[name];
			name = name.toUpperCase();

			switch (typeof value) {
				case "number":
				case "boolean":
					this.line(`#define ${prefix + name} (${value})`);
					break;

				case "string":
					if ("#" == value.charAt(0))
						this.line(`#define ${prefix + name} "${value.substring(1)}"`);
					else
						this.line(`#define ${prefix + name} ${value}`);
					break;

				case "object":
					if (null === value)
						this.line(`#define ${prefix + name} NULL`);
					else if (Array.isArray(value)) {
						this.write(`#define ${prefix + name} {`);
						for (let i = 0, length = value.length; i < length; i++) {
							if (i)
								this.write(", ");
							if ("number" != typeof value[i])
								throw new Error("Array element not number!");
							this.write(value[i]);
						}
						this.write("}\n");
					}
					else
						this.generateDefines(tool, prefix + name + "_", value);
					break;
			}
		}
	}
}

class FormatFile extends PrerequisiteFile {
	constructor(path) {
		super(path);
	}
	generate(tool) {
		this.line("/* MCCONFIG GENERATED FILE; DO NOT EDIT! */");
		this.line("");
		this.line("#define kCommodettoBitmapFormat ", formatValues[tool.format]);
		this.close();
	}
}

class RotationFile extends PrerequisiteFile {
	constructor(path) {
		super(path);
	}
	generate(tool) {
		this.line("/* MCCONFIG GENERATED FILE; DO NOT EDIT! */");
		this.line("");
		this.line("#define kPocoRotation ", tool.rotation);
		this.close();
	}
}

class Rule {
	constructor(tool) {
		this.tool = tool;
	}
	appendFile(files, target, source, include) {
		this.count++;
		source = this.tool.resolveFilePath(source);
		if (!files.already[source]) {
			files.already[source] = true;
			if (include) {
				if (!files.find(file => file.target == target)) {
					let result = { target, source };
					files.push(result);
					return result;
				}
			}
		}
	}
	appendFolder(folders, folder) {
		this.count++;
		if (!folders.already[folder]) {
			folders.already[folder] = true;
			folders.push(folder);
		}
	}
	appendPath(target, path, include, prefix) {
	}
	appendSource(target, source, include, straight) {
	}
	appendTarget(target) {
	}
	iterate(target, source, include, suffix) {
		var tool = this.tool;
		var star = source.lastIndexOf("*");
		this.count = 0;
		if (star >= 0) {
			var slash = source.lastIndexOf(tool.slash);
			var directory = this.tool.resolveDirectoryPath(source.slice(0, slash));
			if (directory) {
				var prefix = source.slice(slash + 1, star);
				var names = FS.readDirSync(directory);
				var c = names.length;
				for (var i = 0; i < c; i++) {
					var name = names[i];
					if (!prefix || name.startsWith(prefix))
						this.appendPath(target, directory + tool.slash + name, include, prefix, suffix);
				}
			}
			else
				tool.reportError(null, 0, "directory not found: " + source);
		}
		else {
			this.appendSource(target, source, include, false, suffix);
		}
		if (!this.count)
			this.noFilesMatch(source, star);
	}
	noFilesMatch(target) {
	}
	process(property) {
		var tool = this.tool;
		var target = "~";
		if (target in property) {
			var sources = property[target];
			if (sources instanceof Array) {
				for (var source of sources) 
					this.iterate(target, source, false);
			}
			else
				this.iterate(target, sources, false);
		}
		for (var target in property) {
			var sources = property[target];
			if (target == "~") {
			}
			else {
				target = tool.resolveSlash(target);
				var slash = target.lastIndexOf(tool.slash);
				if (slash >= 0)
					this.appendTarget(target.slice(0, slash));
				var star = target.lastIndexOf("*");
				if (star >= 0) {
					var suffix = target.slice(star + 1);
					target = target.slice(0, star);
					if (sources instanceof Array) {
						for (var source of sources)
							this.iterate(target, source, true, suffix);
					}
					else
						this.iterate(target, sources, true, suffix);
				}
				else {
					this.count = 0;
					if (sources instanceof Array) {
						for (var source of sources)
							this.appendSource(target, source, true, true, suffix);
					}
					else
						this.appendSource(target, sources, true, true, suffix);
					if (!this.count)
						this.noFilesMatch(source, -1);
				}
			}
		}
	}
};

class DataRule extends Rule {
	appendPath(target, path, include, prefix) {
		var tool = this.tool;
		var parts = tool.splitPath(path);
		this.appendFile(tool.dataFiles, target + parts.name.slice(prefix.length) + parts.extension, path, include);
	}
	appendSource(target, source, include, straight) {
		var tool = this.tool;
		if (FS.existsSync(source) > 0) {
			var parts = tool.splitPath(source);
			this.appendFile(tool.dataFiles, straight ? target : target + parts.name + parts.extension, source, include);
		}
	}
};

class ModulesRule extends Rule {
	appendPath(target, path, include, prefix) {
		var tool = this.tool;
		var parts = tool.splitPath(path);
		if (parts.extension == ".js")
			this.appendFile(tool.jsFiles, target + parts.name.slice(prefix.length) + ".xsb", path, include);
		else if (parts.extension == ".c")
			this.appendFile(tool.cFiles, parts.name + ".c.o", path, include);
		else if (parts.extension == ".cpp")
			this.appendFile(tool.cFiles, parts.name + ".cpp.o", path, include);
		else if (parts.extension == ".java")
			this.appendFile(tool.javaFiles, parts.name + ".class", path, include);
		else if (parts.extension == ".m")
			this.appendFile(tool.cFiles, parts.name + ".m.o", path, include);
		else if (parts.extension == ".h") {
			this.appendFolder(tool.cFolders, parts.directory);
			this.appendFolder(tool.hFiles, path);
		}
	}
	appendSource(target, source, include, straight) {
		var tool = this.tool;
		var path = source + ".js";
		if (FS.existsSync(path) > 0) {
			var parts = tool.splitPath(path);
			this.appendFile(tool.jsFiles, straight ? target + ".xsb" : target + parts.name + ".xsb", path, include);
		}
		var path = source + ".c";
		if (FS.existsSync(path) > 0) {
			var parts = tool.splitPath(path);
			this.appendFile(tool.cFiles, parts.name + ".c.o", path, include);
		}
		var path = source + ".cpp";
		if (FS.existsSync(path) > 0) {
			var parts = tool.splitPath(path);
			this.appendFile(tool.cFiles, parts.name + ".cpp.o", path, include);
		}
		var path = source + ".java";
		if (FS.existsSync(path) > 0) {
			var parts = tool.splitPath(path);
			this.appendFile(tool.javaFiles, parts.name + ".class", path, include);
		}
		var path = source + ".m";
		if (FS.existsSync(path) > 0) {
			var parts = tool.splitPath(path);
			this.appendFile(tool.cFiles, parts.name + ".m.o", path, include);
		}
		var path = source + ".h";
		if (FS.existsSync(path) > 0) {
			var parts = tool.splitPath(path);
			this.appendFolder(tool.cFolders, parts.directory);
			this.appendFolder(tool.hFiles, path);
		}
	}
	appendTarget(target) {
		this.appendFolder(this.tool.jsFolders, target);
	}
	noFilesMatch(source, star) {
		this.tool.reportWarning(null, 0, "no modules match: " + source);
	}
};

class ResourcesRule extends Rule {
	appendBitmap(name, path, include, suffix) {
		var tool = this.tool;
		let colorFile, alphaFile;
		if (tool.bmpAlphaFiles.already[path] || tool.bmpColorFiles.already[path] || tool.bmpMaskFiles.already[path])
			return;
		if (suffix == "-color") {
			colorFile = this.appendFile(tool.bmpColorFiles, name + "-color.bmp", path, include);
		}
		else if (suffix == "-alpha") {
			alphaFile = this.appendFile(tool.bmpAlphaFiles, name + "-alpha.bmp", path, include);
		}
		else if (suffix == "-mask") {
			alphaFile = this.appendFile(tool.bmpMaskFiles, name + "-alpha.bm4", path, include);
		}
		else {
			colorFile = this.appendFile(tool.bmpColorFiles, name + "-color.bmp", path, include);
			alphaFile = this.appendFile(tool.bmpAlphaFiles, name + "-alpha.bmp", path, include);
			alphaFile.colorFile = colorFile;
			colorFile.alphaFile = alphaFile;
		}
		if (colorFile && tool.clutFiles) {
			colorFile.clutName = tool.clutFiles.current;
		}
	}
	appendImage(name, path, include, suffix) {
		var tool = this.tool;
		if (tool.imageFiles.already[path])
			return;
		let file = this.appendFile(tool.imageFiles, name + ".cs", path, include);
		let a = suffix.match(/-image(\(([0-9]+)\))?/);
		file.quality = (a && (a.length == 3) && (a[2] !== undefined)) ? parseInt(a[2]) : undefined;
	}
	appendImageDirectory(name, path, include, suffix) {
		var tool = this.tool;
		var files = tool.imageFiles;
		var source = tool.resolveDirectoryPath(path);
		var target = name + ".cs";
		if (files.already[source])
			return;
		files.already[source] = true;
		if (!include)
			return;
		if (files.find(file => file.target == target))
			return;
		let a = suffix.match(/-image(\(([0-9]+)\))?/);
		let quality = (a && (a.length == 3) && (a[2] !== undefined)) ? parseInt(a[2]) : undefined;
		files.push({ target, source, quality });
		this.count++;
	}
	appendFont(name, path, include, suffix) {
		var tool = this.tool;
		if (suffix == "-mask") {
			this.appendFile(tool.bmpFontFiles, name + ".bf4", path, include);
			return false;
		}
		this.appendFile(tool.resourcesFiles, name + ".fnt", path, include);
		return true;
	}
	appendFormat(parts, path, include, suffix) {
		var tool = this.tool;
		if (tool.format) {
			if (parts.extension == ".act") {
				if (tool.clutFiles) {
					this.appendFile(tool.clutFiles, parts.name + ".cct", path, include);
					tool.clutFiles.current = parts.name;
				}
				else
					this.count++;
				return true;
			}
			if (parts.extension == ".fnt") {
				this.appendFont(parts.name, path, include, suffix);
				return true;
			}
			if ((parts.extension == ".json") && (parts.directory.endsWith("strings"))) {
				this.appendFile(tool.stringFiles, "locals." + parts.name + ".mhr", path, include);
				return true;
			}
			if (parts.extension == ".png") {
				if (suffix.startsWith("-image")) {
					this.appendImage(parts.name, path, include, suffix);
					return true;
				}
				parts.extension = ".fnt";
				if (!tool.bmpFontFiles.already[tool.joinPath(parts)])
					this.appendBitmap(parts.name, path, include, suffix);
				return true;
			}
			if ((parts.extension == ".gif") || (parts.extension == ".jpeg") || (parts.extension == ".jpg")) {
				this.appendImage(parts.name, path, include, suffix);
				return true;
			}
		}
		return false;
	}
	appendPath(target, path, include, prefix, suffix) {
		var tool = this.tool;
		var parts = tool.splitPath(path);
		parts.name = target + parts.name.slice(prefix.length);
		if (this.appendFormat(parts, path, include, suffix)) 
			return;
		for (var extension of resourceExtensions) {
			if (parts.extension == extension)
				this.appendFile(tool.resourcesFiles, parts.name + parts.extension, path, include);
		}
		for (var fps = 1; fps <= 60; fps++) {
			extension = "." + fps + "fps";
			if (parts.extension == extension) {
				this.appendImageDirectory(parts.name, path, include, suffix);
				break;
			}
		}
	}
	appendSource(target, source, include, straight, suffix) {
		var tool = this.tool;
		for (var extension of resourceExtensions) {
			var path = source + extension;
			if (FS.existsSync(path) > 0) {
				var parts = tool.splitPath(path);
				parts.name = straight ? target : target + parts.name;
				if (this.appendFormat(parts, path, include, suffix)) 
					continue;
				this.appendFile(tool.resourcesFiles, parts.name + parts.extension, path, include);
			}
		}
		for (var fps = 1; fps <= 60; fps++) {
			var path = source + "." + fps + "fps";
			if (FS.existsSync(path) < 0) {
				var parts = tool.splitPath(path);
				this.appendImageDirectory(parts.name, path, include, suffix);
				break;
			}
		}
	}
	appendTarget(target) {
		this.appendFolder(this.tool.resourcesFolders, target);
	}
	noFilesMatch(source) {
		this.tool.reportWarning(null, 0, "no resources match: " + source);
	}
};

export default class Tool extends TOOL {
	constructor(argv) {
		super(argv);
		
		this.moddablePath = this.getenv("MODDABLE");
		if (!this.moddablePath)
			throw new Error("MODDABLE: variable not found!");

		this.binPath = null;
		this.config = {};
		this.defines = null;
		this.debug = false;
		this.format = null;
		this.instrument = false;
		this.mainPath = null;
		this.make = false;
		this.manifestPath = null;
		this.outputPath = null;
		this.platform = null;
		this.rotation = 0;
		this.strip = null;
		this.tmpPath = null;
		this.verbose = false;
		this.windows = this.currentPlatform == "win";
		this.slash = this.windows ? "\\" : "/";
		
		this.buildPath = this.moddablePath + this.slash + "build";
		this.xsPath = this.moddablePath + this.slash + "xs";
		
		var name, path;
		var argc = argv.length;
		for (var argi = 1; argi < argc; argi++) {
			var option = argv[argi];
			switch (option) {
			case "-d":
				this.debug = true;
				this.instrument = true;
				break;
			case "-f":
				argi++;	
				if (argi >= argc)
					throw new Error("-f: no format!");
				name = argv[argi];
				if (this.format)
					throw new Error("-f '" + name + "': too many formats!");
				name = name.toLowerCase();
				if (name in formatNames)
					name = formatNames[name];
				else
					throw new Error("-f '" + name + "': unknown format!");
				this.format = name;
				break;
			case "-i":
				this.instrument = true;
				break;
			case "-m":
				this.make = true;
				break;
			case "-o":
				argi++;	
				if (argi >= argc)
					throw new Error("-o: no directory!");
				name = argv[argi];
				if (this.outputPath)
					throw new Error("-o '" + name + "': too many directories!");
				path = this.resolveDirectoryPath(name);
				if (!path)
					throw new Error("-o '" + name + "': directory not found!");
				this.outputPath = path;
				break;
			case "-p":
				argi++;	
				if (argi >= argc)
					throw new Error("-p: no platform!");
				name = argv[argi];
				if (this.platform)
					throw new Error("-p '" + name + "': too many platforms!");
				name = name.toLowerCase();
				if (name in platformNames)
					name = platformNames[name];
				this.platform = name;
				break;
			case "-r":
				argi++;	
				if (argi >= argc)
					throw new Error("-r: no rotation!");
				name = parseInt(argv[argi]);
				if ((name != 0) && (name != 90) && (name != 180) && (name != 270))
					throw new Error("-r: " + name + ": invalid rotation!");
				this.rotation = name;
				break;
			case "-v":
				this.verbose = true;
				break;
			default:
				name = argv[argi];
				let split = name.split("=");
				if (split.length == 2) {
					this.config[split[0]] = split[1];
				}
				else {
					if (this.manifestPath)
						throw new Error("'" + name + "': too many manifests!");
					path = this.resolveFilePath(name);
					if (!path)
						throw new Error("'" + name + "': manifest not found!");
					this.manifestPath = path;
				}
				break;
			}
		}
		if (this.manifestPath) {
			var parts = this.splitPath(this.manifestPath);
			this.currentDirectory = this.mainPath = parts.directory;
		}
		else {
			path = this.resolveFilePath("." + this.slash + "manifest.json");
			if (path)
				this.manifestPath = path;
			else {
				path = this.resolveFilePath(".." + this.slash + "manifest.json");
				if (path)
					this.manifestPath = path;
				else
					throw new Error("no manifest!");
			}
			this.mainPath = this.currentDirectory;
		}
		var parts = this.splitPath(this.mainPath);
		name = parts.name;
		if (!this.outputPath)
			this.outputPath = this.buildPath;
		if (!this.platform)
			this.platform = this.currentPlatform;
		if (this.platform.startsWith("x-"))
			this.format = null;
		else if (!this.format)
			this.format = "rgb565le";
		this.environment = {
			"MODDABLE": this.moddablePath,
			"NAME": name,
		}
		if (this.platform == "mac")
			this.environment.SIMULATOR = this.moddablePath + "/build/bin/mac/debug/Screen Test.app";
		else if (this.platform == "win")
			this.environment.SIMULATOR = this.moddablePath + "\\build\\bin\\win\\debug\\simulator.exe";
		else if (this.platform == "lin")
			this.environment.SIMULATOR = this.moddablePath + "/build/bin/lin/debug/simulator";
	}
	concatProperties(object, properties, flag) {
		if (properties) {
			for (let name in properties) {
				let property = properties[name];
				if (flag) {
					if (property instanceof Array)
						property = property.map(item => this.resolveSource(item));
					else if (typeof property == "string")
						property = this.resolveSource(property);
				}
				object[name] = this.concatProperty((name in object) ? object[name] : [], property);
			}
		}
	}
	concatProperty(array, value) {
		if ((value instanceof Array) || (typeof value == "string"))
			return array.concat(value);
		return array;
	}
	createDirectories(path, first, last) {
		FS.mkdirSync(path);
		path += this.slash + first;
		FS.mkdirSync(path);
		var platform = this.platform;
		if (platform.startsWith("x-")) {
			path += this.slash + platform.slice(2);
			FS.mkdirSync(path);
		}
		else {
			let parts = platform.split("/");
			path += this.slash + parts[0];
			FS.mkdirSync(path);
			if (parts.length > 1) {
				path += this.slash + parts[1];
				FS.mkdirSync(path);
			}
		}
		if (this.debug) 
			path += this.slash + "debug";
		else if (this.instrument) 
			path += this.slash + "instrument";
		else
			path += this.slash + "release";
		FS.mkdirSync(path);
		if ((platform == "mac") || (platform == "win") || (platform == "lin")) {
			path += this.slash + "mc";
			FS.mkdirSync(path);
		}
		if (last) {
			path += this.slash + last;
			FS.mkdirSync(path);
		}
		return path;
	}
	filterRecipe(name, pattern) {
		var star = pattern.lastIndexOf("*");
		if (star >= 0) {
			pattern = pattern.slice(0, star);
			for (var cFile of this.cFiles) {
				var target = cFile.target.slice(0, star);
				if (target == pattern)
					cFile.recipe = name;
			}
		}
		else {
			pattern += ".c";
			for (var cFile of this.cFiles) {
				var target = cFile.target;
				if (target == pattern)
					cFile.recipe = name;
			}
		}
	}
	filterRecipes(recipes) {
		this.recipes = {};
		for (var cFile of this.cFiles)
			cFile.recipe = null;
		for (var name in recipes) {
			var path = this.moddablePath + "/tools/mcconfig/manifest." + this.platform + "." + this.currentPlatform + "." + name + ".mk";
			if (!FS.existsSync(path)) {
				path = this.moddablePath + "/tools/mcconfig/manifest." + this.platform + "." + name + ".mk";
			}
			this.recipes[name] = FS.readFileSync(path);
			var recipe = recipes[name];
			if (recipe instanceof Array) {
				for (var pattern of recipe)
					this.filterRecipe(name, pattern);
			}
			else if (recipe)
				this.filterRecipe(name, recipe);
		}
	}
	includeManifest(name) {
		var currentDirectory = this.currentDirectory;
		var path = this.resolveFilePath(name);
		if (!path)
			throw new Error("'" + name + "': manifest not found!");
		if (this.manifests.already[path])
			throw new Error("'" + name + "': manifest already included!");
		var parts = this.splitPath(path);	
		this.currentDirectory = parts.directory;
		var manifest = this.parseManifest(path);
		manifest.directory = parts.directory;
		this.currentDirectory = currentDirectory;
	}
	mergeManifest(all, manifest) {
		var currentDirectory = this.currentDirectory;
		this.currentDirectory = manifest.directory;
		this.mergePlatform(all, manifest);
		if ("platforms" in manifest) {
			let platform = this.platform;
			let platforms = manifest.platforms;
			for (let name in platforms) {
				if (platform == name)
					this.mergePlatform(all, platforms[name]);
			}
			delete manifest.platforms;
		}
		this.currentDirectory = currentDirectory;
	}
	mergePlatform(all, platform) {
		this.mergeProperties(all.config, platform.config);
		this.mergeProperties(all.creation, platform.creation);
		this.mergeProperties(all.defines, platform.defines);
		
		this.concatProperties(all.data, platform.data, true);
		this.concatProperties(all.modules, platform.modules, true);
		this.concatProperties(all.resources, platform.resources, true);
		this.concatProperties(all.recipes, platform.recipes);
		
		all.commonjs = this.concatProperty(all.commonjs, platform.commonjs);
		all.preload = this.concatProperty(all.preload, platform.preload);
		all.strip = this.concatProperty(all.strip, platform.strip);
	}
	mergeProperties(targets, sources) {
		if (sources) {
			for (let name in sources) {
				let target = targets[name];
				let source = sources[name];
				if (target && source && (typeof target == "object") && (typeof source == "object"))
					this.mergeProperties(target, source);
				else
					targets[name] = source;
			}
		}
	}
	parseBuild(platform) {
		let properties = platform.build;
		if (properties) {
			for (let name in properties) {
				let value = properties[name];
				if (typeof value == "string")
					this.environment[name] = this.resolveVariable(value);
				else
					this.environment[name] = value;
			}
		}
	}
	parseManifest(path) {
		var buffer = FS.readFileSync(path);
		try {
			var manifest = JSON.parse(buffer);
		}
		catch (e) {
			var message = e.toString();
			var result = /SyntaxError: \(host\): ([0-9]+): (.+)/.exec(message);
			if (result.length == 3) {
				this.reportError(path, parseInt(result[1]), result[2]);
			}
			throw new Error("'" + path + "': invalid manifest!");;
		}
		this.manifests.already[path] = manifest;
		this.parseBuild(manifest);
		if ("platforms" in manifest) {
			let platform = this.platform;
			let platforms = manifest.platforms;
			for (let name in platforms) {
				if (platform == name)
					this.parseBuild(platforms[name]);
			}
		}
		if ("include" in manifest) {
			if (manifest.include instanceof Array)
				manifest.include.forEach(include => this.includeManifest(this.resolveVariable(include)));
			else 
				this.includeManifest(this.resolveVariable(manifest.include));
		}
		this.manifests.push(manifest);
		return manifest;
	}
	resolveSlash(value) {
		if (this.windows)
			value = value.replace(/\//g, "\\");
		return value;
	}
	resolveSource(source) {
		var result = this.resolveVariable(source);
		var slash = result.lastIndexOf(this.slash);
		if (slash < 0) 
			throw new Error("'" + source + "': path not found!");
		var directory = this.resolveDirectoryPath(result.slice(0, slash));
		if (!directory) 
			throw new Error("'" + source + "': directory not found!");
		result = directory + result.slice(slash);
		return result;
	}
	resolveVariable(value) {
		value = value.replace(/\$\(([^\)]+)\)/g, (offset, value) => {
			if (value in this.environment)
				return this.environment[value];
			return this.getenv(value);
		});
		return this.resolveSlash(value);
	}
	run() {
		var path = this.manifestPath;
		var manifests = [];
		this.manifests = [];
		this.manifests.already = {};
		var manifest = this.parseManifest(this.manifestPath);
		manifest.directory = this.mainPath;
		var all = {
			config:{},
			creation:{},
			defines:{},
			data:{},
			modules:{},
			resources:{},
			recipes:{},
			preload:[],
			strip:[],
			commonjs:[],
		};
		this.manifests.forEach(manifest => this.mergeManifest(all, manifest));

		let config = all.config;
		this.mergeProperties(config, this.config);
		if (this.format) {
			config.format = formatStrings[this.format];	
			config.rotation = this.rotation;
		}
		this.config = config;
		this.defines = all.defines;
		
		this.dataFiles = [];
		this.dataFiles.already = {};
		this.jsFiles = [];
		this.jsFiles.already = {};
		this.jsFolders = [];
		this.jsFolders.already = {};
		this.cFiles = [];
		this.cFiles.already = {};
		this.cFolders = [];
		this.cFolders.already = {};
		this.hFiles = [];
		this.hFiles.already = {};
		this.javaFiles = [];
		this.javaFiles.already = {};
		this.resourcesFiles = [];
		this.resourcesFiles.already = {};
		this.resourcesFolders = [];
		this.resourcesFolders.already = {};
		if (this.format && this.format.startsWith("clut")) {
			this.clutFiles = [];
			this.clutFiles.already = {};
			this.clutFiles.current = "";
		}
		else
			this.clutFiles = null;
		this.bmpColorFiles = [];
		this.bmpColorFiles.already = {};
		this.bmpAlphaFiles = [];
		this.bmpAlphaFiles.already = {};
		this.bmpFontFiles = [];
		this.bmpFontFiles.already = {};
		this.bmpMaskFiles = [];
		this.bmpMaskFiles.already = {};
		this.imageFiles = [];
		this.imageFiles.already = {};
		this.stringFiles = [];
		this.stringFiles.already = {};
		var rule = new DataRule(this);
		rule.process(all.data);
		var rule = new ModulesRule(this);
		rule.process(all.modules);
		var rule = new ResourcesRule(this);
		rule.process(all.resources);
		
		var folder = "mc";
		if (!this.jsFolders.already[folder]) {
			this.jsFolders.already[folder] = true;
			this.jsFolders.push(folder);
		}
		
		this.preloads = [];
		if (all.preload.length) {
			for (var jsFile of this.jsFiles) {
				jsFile.preload = false;
			}
			for (var pattern of all.preload) {
				pattern = this.resolveSlash(pattern);
				var star = pattern.lastIndexOf("*");
				if (star >= 0) {
					pattern = pattern.slice(0, star);
					for (var result of this.jsFiles) {
						var target = result.target.slice(0, star);
						if (target == pattern) {
							result.preload = true;
							this.preloads.push(result.target);
						}
					}
				}
				else {
					pattern += ".xsb";
					for (var result of this.jsFiles) {
						var target = result.target;
						if (target == pattern) {
							result.preload = true;
							this.preloads.push(result.target);
						}
					}
				}
			}
		}
		this.strip = all.strip;
		if (all.commonjs.length) {
			this.commonjs = true;
			for (var jsFile of this.jsFiles) {
				jsFile.commonjs = false;
			}
			for (var pattern of all.commonjs) {
				pattern = this.resolveSlash(pattern);
				var star = pattern.lastIndexOf("*");
				if (star >= 0) {
					pattern = pattern.slice(0, star);
					for (var result of this.jsFiles) {
						var target = result.target.slice(0, star);
						if (target == pattern)
							result.commonjs = true;
					}
				}
				else {
					pattern += ".xsb";
					for (var result of this.jsFiles) {
						var target = result.target;
						if (target == pattern)
							result.commonjs = true;
					}
				}
			}
		}
			
		this.filterRecipes(all.recipes);
		
		var creation = all.creation;
		if (!creation.chunk) creation.chunk = { };
		if (!creation.chunk.initial) creation.chunk.initial = 32768;
		if (!creation.chunk.incremental) creation.chunk.incremental = 1024;
		if (!creation.heap) creation.heap = { };
		if (!creation.heap.initial) creation.heap.initial = 2048;
		if (!creation.heap.incremental) creation.heap.incremental = 64;
		if (!creation.stack) creation.stack = 512;
		if (!creation.keys) creation.keys = {};
		if (!creation.keys.available) creation.keys.available = 256;
		if (!creation.keys.name) creation.keys.name = 127;
		if (!creation.keys.symbol) creation.keys.symbol = 127;
		if (!creation.static) creation.static = 0;
		if (!creation.main) creation.main = "main";
		if ((this.platform == "x-android") || (this.platform == "x-android-simulator") || (this.platform == "x-ios") || (this.platform == "x-ios-simulator")) {
			creation.main = this.ipAddress;
		}
		this.creation = creation;
		
		var name = this.environment.NAME
		if (!this.binPath) {
			if ((this.platform == "x-ios") || (this.platform == "x-ios-simulator"))
				this.binPath = this.createDirectories(this.outputPath, "bin", name + ".app");
			else if (this.platform == "x-lin")
				this.binPath = this.createDirectories(this.outputPath, "bin");
			else if (this.platform == "x-mac")
				this.binPath = this.createDirectories(this.outputPath, "bin", name + ".app");
			else if (this.platform == "x-win")
				this.binPath = this.createDirectories(this.outputPath, "bin");
			else
				this.binPath = this.createDirectories(this.outputPath, "bin", name);
		}	
		if (!this.tmpPath)
			this.tmpPath = this.createDirectories(this.outputPath, "tmp", name);
		this.modulesPath = this.tmpPath + this.slash + "modules";
		FS.mkdirSync(this.modulesPath);
		for (var folder of this.jsFolders)
			FS.mkdirSync(this.modulesPath + this.slash + folder);

		this.dataPath = this.tmpPath + this.slash + "data";
		FS.mkdirSync(this.dataPath);
		
		if ((this.platform == "x-android") || (this.platform == "x-android-simulator")) {
			var mainPath = this.environment.PROJECT, path;
			if (!mainPath) {
				mainPath = this.binPath;
				this.environment.PROJECT = mainPath;
			}
			mainPath += "/app";
			FS.mkdirSync(mainPath);
			mainPath += "/src";
			FS.mkdirSync(mainPath);
			mainPath += "/main";
			FS.mkdirSync(mainPath);
			
			path = mainPath + "/assets";
			FS.mkdirSync(path);
			this.resourcesPath = path;
			
			path = mainPath + "/cpp";
			FS.mkdirSync(path);
			file = new CMakeListsFile(path + "/CMakeLists.txt");
			file.generate(this);
			
			path = mainPath + "/java";
			FS.mkdirSync(path);
			this.javaPath = path;
		}
		else if ((this.platform == "x-ios") || (this.platform == "x-ios-simulator")) {
			this.resourcesPath = this.binPath;
		}
		else if (this.platform == "x-lin") {
			if (!this.environment.NAMESPACE)
				this.environment.NAMESPACE = "moddable.tech"
			var signature = this.environment.NAME + "." + this.environment.NAMESPACE;
			signature = signature.split(".").reverse();
			this.environment.DASH_SIGNATURE = signature.join("-");
			this.environment.DOT_SIGNATURE = signature.join(".");
			this.environment.SLASH_SIGNATURE = "/" + signature.join("/");
			this.resourcesPath = this.tmpPath + this.slash + "resources";
		}	
		else if (this.platform == "x-mac") {
			var path = this.binPath + "/Contents";
			FS.mkdirSync(path);
			this.binPath = path;
			FS.mkdirSync(path + "/MacOS");
			this.resourcesPath = path + "/Resources";
			FS.mkdirSync(this.resourcesPath);
		}
		else
			this.resourcesPath = this.tmpPath + this.slash + "resources";
		FS.mkdirSync(this.resourcesPath);
		for (var folder of this.resourcesFolders)
			FS.mkdirSync(this.resourcesPath + this.slash + folder);

		var path = this.tmpPath + this.slash + "makefile";
		var file
		if (this.windows) {
			if (this.platform == "synergy")
				file = new SynergyNMakeFile(path);
			else if (this.platform == "esp")
				file = new espNMakeFile(path);
			else
				file = new NMakeFile(path);
		}
		else {
			if ((this.platform == "x-android") || (this.platform == "x-android-simulator"))
				file = new AndroidMakeFile(path);
			else
				file = new MakeFile(path);
		}
		var source = this.tmpPath + this.slash + "mc.config.js";
		var target = "mc" + this.slash + "config.xsb";
		this.jsFiles.push({ source, target });
		
		file.generate(this);

		file = new ConfigFile(source);
		file.generate(this);

		file = new DefinesFile(this.tmpPath + this.slash + "mc.defines.h");
		file.generate(this);
		
		if (this.format) {
			file = new FormatFile(this.tmpPath + this.slash + "mc.format.h");
			file.generate(this);
			file = new RotationFile(this.tmpPath + this.slash + "mc.rotation.h");
			file.generate(this);
		}
		
		if (this.make) {
			if (this.windows)
				this.then("nmake", "/nologo", "/f", path);
			else
				this.then("make", "-f", path);
		}
	}
}
