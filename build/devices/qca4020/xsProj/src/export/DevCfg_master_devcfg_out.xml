<?xml version="1.0"?>
<dal>
<module name="ioe">
<driver name="i2cm">
<!-- I2C Master Configuration
scl_key and sda_key are reserved by the i2c driver.
clock_core_freq_khz: Source clock frequency which will be divided to get the i2C clock.
pu_scl_gpio_encoding and pu_sda_gpio_encoding are the GPIO configurations on power up of the i2c driver
pd_scl_gpio_encoding and pd_sda_gpio_encoding are the GPIO configurations on power down of the i2c driver
Following are the format of these configurations.
Format: GPIO FUNCTION, GPIO DIR, GPIO_PULL, GPIO_DRV_STRENGTH
GPIO FUNCTION values
   GPIO_NONE = 0x0
   GPIO_PWM = 0x1
GPIO DIR values
   GPIO_INPUT = 0x0
   GPIO_OUTPUT = 0x1
GPIO_PULL values
   GPIO_NO_PULL    = 0,    
   GPIO_PULL_DOWN  = 0x1,  
   GPIO_PULL_UP    = 0x2,  
GPIO_DRV_STRENGTH values
   GPIO_1P6MA   = 0,       
   GPIO_2P7MA   = 0x1,     
   GPIO_4P0MA   = 0x2,     
pu_power1, pu_power2, pd_power1 and pd_power2 are i2c power configurations.
These fields are reserved and MUST NOT be altered
-->
  <device id="0x0200000a">
    <props id="0x00000001" id_name="CORE CONFIGURATION" oem_configurable="false" helptext="I2C controller configuration" type="0x00000012">
      I2CCoreConfig01
    </props>
    <props id="0x00000002" id_name="PLATFORM CONFIGURATION" oem_configurable="true" helptext="GPIO encoding bitmap {Format 0xXX (LSB), 0xXX, 0xXX, 0xXX(MSB)}: function[3:0] | gpio[13:4] | direction[14] -> 0 - INPUT, 1 = OUTPUT | pull[16:15] -> 0 - NO_PULL, 1 - PULL_DOWN, 2 - PULL_UP | drive_strength[20:17] -> 0 - 1.6mA, 1 - 2.7mA, 2 - 4mA | gpio_version[31:28] -> 2, I2C Core Clock Frequency: i2c core clock frequency in KHz (ex. 20 MHz = 0x00004E20 KHz)" type="0x00000008">
      <!-- .scl_key                 = --> 0x00, 0x00, 0x00, 0x00, 
      <!-- .sda_key                 = --> 0x00, 0x00, 0x00, 0x00, 
      <!-- .clock_core_freq_khz     = --> 0x20, 0x4E, 0x00, 0x00, 
      <!-- .pu_scl_gpio_encoding    = --> 0xA1, 0x40, 0x01, 0x20, 
      <!-- .pu_sda_gpio_encoding    = --> 0xB1, 0x40, 0x01, 0x20, 
      <!-- .pu_power1               = --> 0x03, 0x00, 0x00, 0x00, 
      <!-- .pu_power2               = --> 0x02, 0x00, 0x00, 0x00, 
      <!-- .pd_scl_gpio_encoding    = --> 0xA0, 0x00, 0x01, 0x20, 
      <!-- .pd_sda_gpio_encoding    = --> 0xB0, 0x00, 0x01, 0x20, 
      <!-- .pd_power1               = --> 0x00, 0x00, 0x00, 0x00, 
      <!-- .pd_power2               = --> 0x00, 0x00, 0x00, 0x00, 
      end
    </props>
  </device>
</driver>
<driver name="quadspi">
   <global_def>
      <var_seq name="num_arr" id_name="GPIO number array" oem_configurable="false" helptext="Array of GPIO numbers used for QuadSPI" type="0x00000002">42,43,44,45,46,47,end</var_seq>
      <var_seq name="func_arr" id_name="GPIO function select array" oem_configurable="false" helptext="Array of function selects used for QuadSPI GPIOs" type="0x00000002">1,1,1,1,1,1,end</var_seq>
      <var_seq name="act_pull_arr" id_name="GPIO active pull array" oem_configurable="true" helptext="Array of active pulls used for QuadSPI GPIOs. Encoding Map: 0 - No Pull, 1 - Pull Down, 2 - Pull Up" type="0x00000002">0,1,1,1,1,0,end</var_seq>
      <var_seq name="act_drv_arr" id_name="GPIO active drive array" oem_configurable="true" helptext="Array of active drive strengths used for QuadSPI GPIOs. Encoding Map: 0 - 4mA, 1 - 2.7mA, 2 - 1.6mA" type="0x00000002">0,0,0,0,0,0,end</var_seq>
      <var_seq name="inact_pull_arr" id_name="GPIO inactive pull array" oem_configurable="true" helptext="Array of inactive pulls used for QuadSPI GPIOs. Encoding Map: 0 - No Pull, 1 - Pull Down, 2 - Pull Up" type="0x00000002">1,1,1,1,1,1,end</var_seq>
      <var_seq name="inact_drv_arr" id_name="GPIO inactive drive array" oem_configurable="true" helptext="Array of inactive drive strengths used for QuadSPI GPIOs. Encoding Map: 0 - 4mA, 1 - 2.7mA, 2 - 1.6mA" type="0x00000002">0,0,0,0,0,0,end</var_seq>
   </global_def>
   <device id="0x0200001b">
      <props id="0x10000" id_name="GPIO number array pointer" oem_configurable="false" type="0x00000018">num_arr</props>
      <props id="0x10001" id_name="GPIO function select array pointer" oem_configurable="false" type="0x00000018">func_arr</props>
      <props id="0x10002" id_name="GPIO active pull array pointer" oem_configurable="false" type="0x00000018">act_pull_arr</props>
      <props id="0x10003" id_name="GPIO active drive array pointer" oem_configurable="false" type="0x00000018">act_drv_arr</props>
      <props id="0x10004" id_name="GPIO inactive pull array pointer" oem_configurable="false" type="0x00000018">inact_pull_arr</props>
      <props id="0x10005" id_name="GPIO inactive drive array pointer" oem_configurable="false" type="0x00000018">inact_drv_arr</props>
   </device>
</driver>
<driver name="spi1">
<!-- GPIO configuration calculations
GPIO DIR values
   GPIO_INPUT = 0x0
   GPIO_OUTPUT = 0x1
GPIO_PULL values
   GPIO_NO_PULL    = 0,    
   GPIO_PULL_DOWN  = 0x1,  
   GPIO_PULL_UP    = 0x2,  
GPIO_DRV_STRENGTH values
   GPIO_1P6MA   = 0,       
   GPIO_2P7MA   = 0x1,     
   GPIO_4P0MA   = 0x2,     
GPIO configuration =  (GPIO_NUM           & 0xFF) << 0x10 |
                      (GPIO_FS_VAL        &  0xF) <<  0xC |
                      (GPIO_DRV_STRENGTH  &  0xF) <<  0x8 |
                      (GPIO_PULL          &  0xF) <<  0x4 |
                      (GPIO_DIR           &  0xF)
-->
   <device id="0x02000010">
      <props id="0x21001"  id_name="SPI Core Configuration" oem_configurable="false" helptext="SPI Master Core Configuration" type="0x00000012"> spi_first_port  </props>
	  <props id="0x2100A" id_name="SPI Controller Board Specific Configuration" oem_configurable="true" helptext="GPIO encoding {Format 0xXX (LSB), 0xXX, 0xXX, 0xXX(MSB)} : 1st 8 bits =  pull[7:4] -> 0 - NO_PULL, 1 - PULL_DOWN, 2 - PULL_UP | direction[3:0] -> 0 - INPUT, 1 = OUTPUT , 2nd 8 bits = drive_strength[7:4] -> 0 - 1.6mA, 1 - 2.7mA, 2 - 4mA | function[3:0], 3rd 8 bits = gpio pin[7:0] -> pin number, 4th 8 bits {unused[7:0] -> Reserved"  type="0x00000008">
         <!-- MOSI GPIO key               = --> 0x00, 0x00, 0x00, 0x00,
         <!-- MISO GPIO key               = --> 0x00, 0x00, 0x00, 0x00,
         <!-- CS GPIO key                 = --> 0x00, 0x00, 0x00, 0x00,
         <!-- CLK GPIO key                = --> 0x00, 0x00, 0x00, 0x00,
		 <!-- PU MOSI GPIO encoding       = --> 0x01, 0x12, 0x1A, 0x00, 
         <!-- PU MISO GPIO encoding       = --> 0x00, 0x12, 0x1B, 0x00,
         <!-- PU CS GPIO encoding         = --> 0x01, 0x12, 0x18, 0x00,
         <!-- PU CLK GPIO encoding        = --> 0x01, 0x12, 0x19, 0x00,
         <!-- PD MOSI GPIO encoding       = --> 0x10, 0x00, 0x1A, 0x00,
         <!-- PD MISO GPIO encoding       = --> 0x10, 0x00, 0x1B, 0x00,
         <!-- PD CS GPIO encoding         = --> 0x20, 0x00, 0x18, 0x00,
         <!-- PD CLK GPIO encoding        = --> 0x10, 0x00, 0x19, 0x00,
         <!-- CS 1 GPIO key               = --> 0x00, 0x00, 0x00, 0x00,
         <!-- PU CS 1 GPIO encoding       = --> 0x00, 0x00, 0x00, 0x00,
         <!-- PD CS 1 GPIO encoding       = --> 0x20, 0x00, 0x00, 0x00,
	     end
	  </props>
      <props id="0x2100B" id_name="SPI BAM Configuration" oem_configurable="true" helptext="SPI BAM mode enable" type="0x00000002"> 1 </props>
   </device>
</driver>
<driver name="Dog_Cfg">
  <device id="0x02000019">
    <!-- If this flag is set to 0x0, hw wdog and grace timer will be initialized -->
    <!-- If this flag is set to 0x1, hw wdog and grace timer will NOT be initialized -->
    <props name="dog_hal_disable" type="0x00000002">
      0
    </props>
    <!-- Grace timer value in sclk, This timer will declare a stalled initialization,
	 if intialization does not complete before it times out. -->
    <props name="dog_hal_grace_timer_timeout" type="0x00000002">
      1280000 <!-- s*32000, 40s -->
    </props>
  </device>
</driver>
<driver name="Adc">
  <device id="0x02000003">
    <props id="0" oem_configurable="false" type="0x00000012">
      gAdcBsp
    </props>
    <props id="1" oem_configurable="true" helptext="Common settings for ADC" id_name="ADC_COMMON_SETTINGS" type="0x00000008">
      <!-- Values for ucAvgMode: -->
      <!-- 0: ADC_AVG_MODE_NONE       -->
      <!-- 1: ADC_AVG_MODE_2_SAMPLES  -->
      <!-- 2: ADC_AVG_MODE_4_SAMPLES  -->
      <!-- 3: ADC_AVG_MODE_8_SAMPLES  -->
      <!-- 4: ADC_AVG_MODE_16_SAMPLES -->
      <!-- 5: ADC_AVG_MODE_32_SAMPLES -->
      <!-- 6: ADC_AVG_MODE_64_SAMPLES -->
      <!-- Values for ucAnaClockRate -->
      <!-- 1: ADC_ANA_CLOCK_RATE_31P25_KHZ -->
      <!-- 2: ADC_ANA_CLOCK_RATE_62P5_KHZ  -->
      <!-- 4: ADC_ANA_CLOCK_RATE_125_KHZ   -->
      <!-- 8: ADC_ANA_CLOCK_RATE_250_KHZ   -->
      <!-- 16: ADC_ANA_CLOCK_RATE_500_KHZ  -->
      <!-- 32: ADC_ANA_CLOCK_RATE_1_MHZ    -->
      <!-- 64: ADC_ANA_CLOCK_RATE_2_MHZ    -->
      <!-- Values for ucFilterMode -->
      <!-- 0: ADC_FILTER_MODE_NYQUIST_ZERO       -->
      <!-- 1: ADC_FILTER_MODE_NYQUIST_RANDOMIZED -->
      <!-- 2: ADC_FILTER_MODE_OVERSAMPLING       -->
      <!-- usSampleIntervalTicks is in the format <LSB, MSB> -->
      <!-- usRecalTimeSec is in the format <LSB, MSB> -->
      <!-- .ucAvgMode             = --> 0,
      <!-- .ucAnaClockRate        = --> 64,
      <!-- .ucFilterMode          = --> 0,
      <!-- .ucNumAcqs             = --> 1,
      <!-- .usSampleIntervalTicks = --> 0, 0,
      <!-- .usRecalTimeSec        = --> 60, 0,
      end
    </props>
    <props id="2" oem_configurable="true" helptext="List of ADC channels and settings for each channel" id_name="ADC_CHANNEL_SETTINGS" type="0x00000008">
      <!-- Values for ucInput -->
      <!-- 0: ADC_INPUT_SINGLE_ENDED -->
      <!-- 1: ADC_INPUT_DIFFERENTIAL -->
      <!-- usSamplesPerAcq is in the format <LSB, MSB> -->
      <!-- Values for ucOsr -->
      <!-- 0: ADC_OSR_2  -->
      <!-- 1: ADC_OSR_4  -->
      <!-- 2: ADC_OSR_8  -->
      <!-- 3: ADC_OSR_16 -->
      <!-- Channel 0 -->
      <!-- .ucHwChan        = --> 0,
      <!-- .ucInput         = --> 0,
      <!-- .usSamplesPerAcq = --> 1, 0,
      <!-- .ucOsr           = --> 0,
      <!-- Channel 1 -->
      <!-- .ucHwChan        = --> 1,
      <!-- .ucInput         = --> 0,
      <!-- .usSamplesPerAcq = --> 1, 0,
      <!-- .ucOsr           = --> 0,
      <!-- Channel 2 -->
      <!-- .ucHwChan        = --> 2,
      <!-- .ucInput         = --> 0,
      <!-- .usSamplesPerAcq = --> 1, 0,
      <!-- .ucOsr           = --> 0,
      <!-- Channel 3 -->
      <!-- .ucHwChan        = --> 3,
      <!-- .ucInput         = --> 0,
      <!-- .usSamplesPerAcq = --> 1, 0,
      <!-- .ucOsr           = --> 0,
      <!-- Channel 4 -->
      <!-- .ucHwChan        = --> 4,
      <!-- .ucInput         = --> 0,
      <!-- .usSamplesPerAcq = --> 1, 0,
      <!-- .ucOsr           = --> 0,
      <!-- Channel 5 -->
      <!-- .ucHwChan        = --> 5,
      <!-- .ucInput         = --> 0,
      <!-- .usSamplesPerAcq = --> 1, 0,
      <!-- .ucOsr           = --> 0,
      <!-- Channel 6 -->
      <!-- .ucHwChan        = --> 6,
      <!-- .ucInput         = --> 0,
      <!-- .usSamplesPerAcq = --> 1, 0,
      <!-- .ucOsr           = --> 0,
      <!-- Channel 7 -->
      <!-- .ucHwChan        = --> 7,
      <!-- .ucInput         = --> 0,
      <!-- .usSamplesPerAcq = --> 1, 0,
      <!-- .ucOsr           = --> 0,
      end
    </props>
  </device>
</driver>
<driver name="Tsens">
  <device id="0x02000004">
    <props id="0" oem_configurable="false" type="0x00000012">
      gTsensBsp
    </props>
  </device>
</driver>
<driver name="PWM">
<!--  GPIO configuration parameters details for pwm_gpio_active_arr and pwm_gpio_default_arr
Format: GPIO FUNCTION, GPIO DIR, GPIO_PULL, GPIO_DRV_STRENGTH
GPIO FUNCTION values
   GPIO_NONE = 0x0
   GPIO_PWM = 0x1
GPIO DIR values
   GPIO_INPUT = 0x0
   GPIO_OUTPUT = 0x1
GPIO_PULL values
   GPIO_NO_PULL    = 0,    
   GPIO_PULL_DOWN  = 0x1,  
   GPIO_PULL_UP    = 0x2,  
GPIO_DRV_STRENGTH values
   GPIO_1P6MA   = 0,       
   GPIO_2P7MA   = 0x1,     
   GPIO_4P0MA   = 0x2,     
-->
<!-- Clock frequency configurations for pwm_clk_arr
Various frequency configurations in different modes of the life cycle. 
Clock selection for different modes are described under pwm_Source_CLK_t 
-->
   <global_def>
     <var_seq name="pwm_gpio_arr" type="0x00000002" helptext="List of GPIOs which corresponds to the PWM channels">
      18, 19, 20, 21, 22, 23, 12, 13, 
      end
     </var_seq>
     <var_seq name="pwm_channel_arr" type="0x00000002" helptext="PWM channel numbers mapped to the above GPIOs in order">
      6, 1, 2, 4, 3, 5, 0, 7, 
      end
     </var_seq>
     <var_seq name="pwm_gpio_active_arr" type="0x00000002" helptext="GPIO configuration parameters when PWM is active">
      1, 1, 0, 0,
      1, 1, 0, 0,
      1, 1, 0, 0,
      1, 1, 0, 0,
      1, 1, 0, 0,
      1, 1, 0, 0,
      1, 1, 0, 0,
      1, 1, 0, 0,
      end
     </var_seq>
     <var_seq name="pwm_gpio_default_arr" type="0x00000002" helptext="GPIO configuration parameters when PWM is inactive">
      0, 0, 1, 0,
      0, 0, 1, 0,
      0, 0, 1, 0,
      0, 0, 1, 0,
      0, 0, 1, 0,
      0, 0, 1, 0,
      0, 0, 1, 0,
      0, 0, 1, 0,
      end
     </var_seq>
     <var_seq name="pwm_clk_arr" type="0x00000003" helptext="Various clock configuration for various clock modes defined by pwm_Source_CLK_t">
      40000000, 38500000, 32000, 64000000, 32000000, 40000000, 
      end
     </var_seq>
   </global_def>
   <device id="0x02000002">
     <props id="0" type="0x00000018">
      pwm_gpio_arr
     </props>
     <props id="1" type="0x00000018">
      pwm_channel_arr
     </props>
     <props id="2" type="0x00000018">
      pwm_gpio_active_arr
     </props>
     <props id="3" type="0x00000018">
      pwm_gpio_default_arr
     </props>
     <props id="4" type="0x00000014">
      pwm_clk_arr
     </props>
     <props id="5" type="0x00000002">
      2
     </props>
   </device>
</driver>
<driver name="platform">
  <device id="0x02000006">
    <props id="1" id_name="PLATFORM DEP ENABLE" oem_configurable="true" helptext="Enable or disable data execution prevention." type="0x00000002">
       1
    </props>
    <props id="2" id_name="PLATFORM DEP CONFIGURATION" oem_configurable="true" helptext="Data execution prevention configuration." type="0x00000008">
	<!-- All the data is in Little Endian Format -->
    <!-- FORMAT: -->
    <!-- DEP_region_start_address - 4 bytes -->
    <!-- DEP_region_size - 4 bytes -->
    <!-- DEP_region_index - 1 byte -->
    <!-- DEP_sub_region_mask - 1 byte (set bit to '1' for disabling the sub-region) -->
    <!-- DEP_access_control - 1 byte (0x6 for RO, 0x3 for RW) -->
    <!-- XN - 1 byte -->
    <!-- 64MB ROM region          = --> 0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x06, 0x00,
    <!-- 1MB RAM region           = --> 0x00, 0x00, 0x00, 0x10,  0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x03, 0x01,
    <!-- FOM Code and Data region = --> 0x00, 0x00, 0x00, 0x10,  0x00, 0x00, 0x10, 0x00, 0x02, 0xF1, 0x06, 0x00,
    <!-- FOM APPS region          = --> 0x00, 0x00, 0x08, 0x10,  0x00, 0x00, 0x01, 0x00, 0x03, 0xFF, 0x06, 0x00,
    <!-- SOM Code and Data region = --> 0x00, 0x40, 0x00, 0x10,  0x00, 0x40, 0x00, 0x00, 0x04, 0x01, 0x06, 0x00,
    <!-- SOM APPS and HEAP        = --> 0x00, 0x80, 0x00, 0x10,  0x00, 0x80, 0x00, 0x00, 0x05, 0xE0, 0x06, 0x00,
    <!-- MOM region               = --> 0x00, 0x10, 0x00, 0x10,  0x00, 0x10, 0x00, 0x00, 0x06, 0xC7, 0x06, 0x00,
	<!-- SBL region               = --> 0x00, 0x00, 0x0A, 0x10,  0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x3, 0x01,
    end
    </props>
    <props id="3" id_name="PLATFORM SMEM PROPERTY" oem_configurable="true" helptext="Number of clients supported by SMEM." type="0x00000002">
       10
    </props>
    <props id="5"  id_name="PLATFORM NUM DSR" oem_configurable="true" helptext="Number of DSR threads." min="1" max="3" type="0x00000002">
       1
    </props>
    <props id="6" id_name="PLATFORM SYSPM SRC" oem_configurable="true" helptext="32KHz sleep clock source. 0--LFRCO, 5--XTAL 32k, 10--GPIO 32k" type="0x00000002">
      0
    </props>
    <props id="7" id_name="PLATFORM RAMDUMP ENABLED" oem_configurable="true" helptext="Enable or Disable Ramdump. 1--Enabled, 0--Disabled" type="0x00000002">
      1
    </props>
    <props id="8" id_name="PLATFORM MAX TIMERS" oem_configurable="true" helptext="Maximum running timers allowed" type="0x00000002">
      10
    </props>
    <props id="9" id_name="PLATFORM TRIM ENABLED" oem_configurable="false" helptext="Enable or disable voltage trimming. 1--Enabled, 0--Disabled" type="0x00000002">
      1
    </props>
    <props id="10" id_name="PLATFORM VOLTAGE ADJUST" oem_configurable="false" helptext="Used to adjust an entire SKU or product line from the target voltage." type="0x00000002">
      0
    </props>
    <props id="11" id_name="PLATFORM RAMDUMP CONFIG" oem_configurable="true" helptext="Configure the RAM Dump. " type="0x00000002">
	  <!-- Mask - PPPPRRRT -->
	  <!-- Where bits in 0xT represent following -->
	  <!-- Bit 0: If set, enable the RAM dump via Uart/USB support otherwise disabled  -->
      <!-- Bit 1: If set, enable the RAM dump on QSPI Flash support otherwise disabled -->
      <!-- Bit 2 and Bit 3 are reserved for future use                                 -->   
	  <!-- Where bits in R are reserved for future use                                 --> 
	  <!-- Where bits in P represent the 16 bit USB PID                                -->
      0x900E0003
    </props>
	<props id="12"  id_name="PLATFORM USB PID" oem_configurable="true" helptext="USB PID during the Mission Mode" type="0x00000002">0x00009055</props>
  </device>
</driver>
<driver name="Sleep">
  <global_def>
    <var_seq name="devcfgSleepData" type="0x00000003">
        0, 0, 0,
        180, 166, 200,
        end
    </var_seq>
  </global_def>
  <device id="0x02000018">
    <props id="0x1" oem_configurable="false" type="0x00000014"> devcfgSleepData </props>
    <props id="0x2" oem_configurable="false" type="0x00000002"> 1 </props>
    <props id="0x3" oem_configurable="false" type="0x00000002"> 632 </props>
    <props id="0x4" oem_configurable="false" type="0x00000002"> 96 </props>
  </device>
</driver>
<driver name="diag">
<!-- 
 Configuration for:
 0.	0: Property ID that is a byte sequence defining
 	MSGLEVEL, Output Drain Channel and Flash rate based on system wide buffer
 	threshold.
 	MSGLEVEL:
 		Diag debug message level.
 		Default Value: DIAG_MSG_LVL_MED (2)
 		This turns on all Modules and sets system debugmessage level to Medium
 		unless tool is connected and changes the level or module-mask at
 		run-time.
	 	To turn off everything, define this to 0xFF (0xFF, defined
	 	in diag_devcfg.h)
 	Output Drain Channel:
 		Peripheral (external transport or internal non-transport) configured as
		output drain channel for DIAG logs.
 		Default Value: 1 (1)
 		Other options available are:
		 For external transport: Debug-UART. 2 (2)
		 						 Debug-MML. 4 (4)*
		 For internal non-transport: Debug-Flash. 3 (3)
		* 4 is added to support new transports which
		interfaces with DIAG via a transport specific messaging service
		(like MML, Message Management Layer). Selection of transport is done by
		the MML layer and made known to DIAG when MML registers with DIAG using
		qapi_diag_tr_service_register(). Both MML and DIAG can distinguish
		the transport beneath using service ID provided by MML to DIAG at
		registration with DIAG. So DIAG is agnostic to the transport beneath
		MML.
 		All options are defined in diag_devcfg_ram.h
 	Flash rate based on system wide buffer threshold:
 		If Output Drain Channel is configured to 3 (3),
 		logs dumped by client to system wide buffer are drained to Flash when
 		buffered logs exceeds this threshold.
 		Default Value: 64 (in Bytes)
 		Valid Range: 64-255
 	The default setting for this is as follows:
 	2                      ,  1                                 ,    64
	Valid value/ranges:
 	DIAG_MSG_LVL_LOW (1)/  | 1 (1)/      |    (64-255)
 	DIAG_MSG_LVL_MED (2)/  | 2 (2)/  |
 	DIAG_MSG_LVL_HIGH (3)/ | 3 (3) /   |
 	0xFF     | 4 (4)       |
 1. 1
 	Maximum size of diag response packet (response to command packet 75).
 	Default Value: 256
 	Might need to be changed to 2048 for manufacturing mode image since WLAN
 	requires to send 2KByte responses.
 2. 2
 	Maximum size of diag request (a.k.a incoming command, Tool->device) packet
 	(packet 75).
 	Default Value: 256
 	Might need to be changed to 512 for manufacturing mode image since WLAN
 	requires larger incoming commands.
 	NOTE: Largest tested value is 512 bytes, any increase beyond 512 could be
 	RISKY
 3. 3
 	If Output Drain Channel is configured to 3 (3),
 	logs dumped by client to system wide buffer are drained to Flash after this
 	time period has elapsed.
 	Default Value: 500 (ms)
 	Valid Range: 50-1000
 NOTE: For invalid values, DEFAULT values are effective.
 -->
  <device id="0x02000014">
    <props id="0" type="0x00000008">
    <!-- Last byte is unused placeholder --> 2, 1, 64, 0,
    end
    </props>
    <props id="1" type="0x00000002">256</props>
    <props id="2" type="0x00000002">256</props>
	<props id="3" type="0x00000002">500</props>
  </device>
</driver>
<driver name="GPIOInt">
  <device id="0x02000015">
    <props id="0x55" type="0x00000012">
      gGPIOIntConfigTable
    </props>
    <props id="0x56" type="0x00000002">
      4
    </props>
  </device>
</driver>
<driver name="InterruptController">
  <device id="0x02000016">
    <props id="0x5A" type="0x00000012">
      InterruptControllerPriorityConfig
    </props>
    <props id="0x5B" type="0x00000002">
      64
    </props>
  </device>
</driver>
<driver name="IPCInt">
  <device id="0x02000017">
    <props id="0x57" type="0x00000012">
      IPCIntConfig
    </props>
    <props id="0x58" type="0x00000012">
      IPCIntIRQData
    </props>
    <props id="0x59" type="0x00000002">
      4
    </props>
  </device>
</driver>
<driver name="Timetick">
<!-- Time tick Configurations
  TIMER_CALIBRATION_INTERVAL_SEC defines the interval in seconds to
  perform the timer tick calibration. This calibration is required to 
  adjust the drift resulting from repeated sleep/wake cycles.
  TIMER_FREQ defines the frequency of the timer. It is recommended to
  keep this value as one of the divisible value of master clock 
  to overcome larger drift.
-->
  <device id="0x0200001a">
    <props name="TIMER_CALIBRATION_INTERVAL_SEC" type="0x00000002">
       <!-- Timer Calibration interval in seconds  = -->  3600
    </props>
    <props name="TIMER_FREQ" type="0x00000002">
       <!-- Timer frequency = -->  32000
    </props>
  </device>
</driver>
</module>
</dal>
